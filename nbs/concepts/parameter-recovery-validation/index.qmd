---
title: Parameter Recovery Validation
toc: true
number-sections: true
highlight-style: gruvbox
csl: ../../bibstyle.csl
lightbox: auto
format:
  html:
    html-math-method: mathjax
    include-in-header: ../../mathjax.html
format-links: [ipynb]
execute:
  freeze: true
  eval: true
  warning: false
  error: false
  cache: true
author:
  - name: Pyrovelocity Team
    email: team@pyrovelocity.net
abstract: |
  This notebook demonstrates parameter recovery validation for PyroVelocity models using the direct dimensionless approach,
  progressing from analytical solutions with observed time to numerical simulation with latent time coordinates.
  We focus on models that naturally avoid identifiability issues while maintaining biological interpretability,
  using hierarchical priors on characteristic scales and lumped effective capture efficiency.
  We illustrate how to systematically validate that probabilistic models can recover
  known parameters from synthetic data, which is essential before applying models
  to real-world data where true parameter values are unknown.
keywords: [single-cell transcriptomics, probabilistic modeling, model calibration, model validation, RNA velocity]
bibliography: ../../references.bib
jupyter:
  jupytext:
    cell_metadata_filter: all
    cell_metadata_json: true
    notebook_metadata_filter: all
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: 1.0
      jupytext_version: 1.16.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
  language_info:
    name: python
  rise:
    scroll: true
    theme: black
  toc-autonumbering: true
  toc-showcode: false
  toc-showmarkdowntxt: false
---

## Introduction

Parameter recovery validation is a critical step in validating probabilistic models before applying them to real data. This process involves:

1. **Generating synthetic data** using known parameter values
2. **Running inference** to recover parameters from the synthetic data
3. **Evaluating recovery performance**
4. **Assessing model identifiability**

This notebook demonstrates parameter recovery validation for PyroVelocity models using the dimensionless parameterization that naturally avoids identifiability issues while maintaining biological interpretability. We implement hierarchical priors on characteristic scales and lumped effective capture efficiency, progressing from analytical solutions with observed time to numerical simulation with latent time coordinates. For each model we include a graphical representation of the model's generative process as well as a mathematical description of the prior, observation model, and likelihood.

## Model Progression

We validate parameter recovery across a progression of **dimensionless models** that naturally avoid identifiability issues while maintaining biological interpretability. Each model builds complexity while preserving the core dimensionless parameterization.

### Dimensionless Analytical Dynamics with Observed Time

This model uses the direct dimensionless approach with analytical solutions:

- **Time coordinates**: Observed dimensionless time $t^*_j$
- **Dynamics**: Analytical dimensionless transcription-splicing-degradation solutions
- **Parameters**: $\gamma^*_i$ (relative degradation), $U_{0i}$ (characteristic scale), $\lambda_j$ (lumped capture efficiency)
- **Prior**: Log-normal hierarchical priors for all parameters
- **Observation Model**: Poisson counts scaled by characteristic scales and capture efficiency
- **Likelihood**: Poisson product distribution
- **Identifiability**: Naturally identifiable through dimensionless parameterization

### Dimensionless Analytical Dynamics with Latent Time

This model introduces latent dimensionless time coordinates:

- **Time coordinates**: Latent $t^*_j$ with hierarchical Gamma/Normal priors
- **Dynamics**: Same dimensionless analytical solutions
- **Parameters**: $\gamma^*_i$, $U_{0i}$, $\lambda_j$, plus hierarchical time structure ($T_{M}^*$, $t_{loc}$, $t_{scl}$)
- **Prior**: Gamma priors for time scales, Normal for relative positions
- **Observation Model**: Same Poisson scaling approach
- **Likelihood**: Poisson

### Dimensionless Simulated Dynamics with Observed Time

This model replaces analytical solutions with numerical integration:

- **Time coordinates**: Observed dimensionless time $t^*_j$
- **Dynamics**: Numerical integration of dimensionless ODEs using torchode
- **Parameters**: $\gamma^*_i$, $U_{0i}$, $\lambda_j$
- **Prior**: Log-normal hierarchical priors
- **Observation Model**: Same Poisson scaling approach
- **Likelihood**: Poisson

### Dimensionless Simulated Dynamics with Latent Time

This model represents the full complexity of the PyroVelocity modular implementation:

- **Time coordinates**: Latent $t^*_j$ with hierarchical Gamma/Normal priors
- **Dynamics**: Numerical integration of dimensionless ODEs using torchode
- **Parameters**: $\gamma^*_i$, $U_{0i}$, $\lambda_j$, plus hierarchical time structure ($T_{M}^*$, $t_{loc}$, $t_{scl}$)
- **Prior**: Gamma priors for time scales, Normal for relative positions
- **Observation Model**: Same Poisson scaling approach
- **Likelihood**: Poisson

## Parameter Recovery Validation Framework

```{python}
#| label: setup-imports
#| code-fold: true

import numpy as np
import torch
import pyro
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

# PyroVelocity imports
from pyrovelocity.models.modular.factory import (
    create_simple_deterministic_model_with_validation,
    create_legacy_model2,
)
from pyrovelocity.models.modular.components.validation import (
    ParameterRecoveryConfig,
)
from pyrovelocity.io.datasets import bifurcation_14

# Set random seeds for reproducibility
torch.manual_seed(42)
pyro.set_rng_seed(42)
np.random.seed(42)

print("Setup complete!")
```

## Validation Study 1: Dimensionless analytical dynamics with observed time

This validation study focuses on the **direct dimensionless approach** that naturally avoids identifiability issues while maintaining biological interpretability. We follow the theoretical foundation from our [Probabilistic inference in dynamical systems](../inferenceindynamicalsystems/index.qmd) concept guide, implementing hierarchical priors on characteristic scales and lumped effective capture efficiency.

### Model Description

We model the transcription-splicing-degradation system using the **direct dimensionless approach** that naturally avoids identifiability issues while maintaining biological interpretability. This approach fits the dimensionless model directly with hierarchical priors on characteristic scales, eliminating the need for post-estimation rescaling procedures.

The model generates count data for unspliced ($u$) and spliced ($s$) RNA molecules per cell, with dynamics governed by the dimensionless analytical solutions and observation model that scales back to dimensional counts through characteristic scales and effective capture efficiency.

### Probabilistic Graphical Model

The probabilistic graphical model represents the dimensionless transcription-splicing-degradation system with hierarchical priors on characteristic scales and lumped effective capture efficiency. The model directly fits dimensionless parameters while maintaining biological interpretability through characteristic scales.

```{python}
#| label: fig-count-model-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for the dimensionless transcription-splicing-degradation model with hierarchical priors on characteristic scales and lumped effective capture efficiency.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters
pgm.add_node("mu_init", r"$\mu_{0}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_init", r"$\sigma_{0}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 5.5, 5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6, 5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("u_star_0i", r"$u^{\ast}_{0i}$", 1, 5)
pgm.add_node("s_star_0i", r"$s^{\ast}_{0i}$", 2, 5)
pgm.add_node("gamma_star_i", r"$\gamma^{\ast}_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# cell-specific parameters (moved inside cell plate)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 4)

# latent variables for cell-specific outcomes
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    4,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    4,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "t_star_j",
    r"$t^{\ast}_j$",
    5.5,
    3.0,
    observed=True,
    shape="rectangle",
)
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.5,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.5,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}
pgm.add_edge("mu_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("mu_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

pgm.add_edge("u_star_0i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("s_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("u_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)

pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.4, 4.5, 4.2],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.0, 1.9, 5.0, 2.6],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model is defined by the following hierarchical structure using the **direct dimensionless approach**:

**Priors for dimensionless initial conditions:**
\begin{align}
    u^*_{0i}, s^*_{0i} &\sim \text{LogNormal}(\mu_{0}, \sigma_{0}^2) \label{eq-dimless-init-conds-priors}
\end{align}

**Priors for dimensionless kinetic parameters:**
\begin{align}
    \gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \label{eq-gamma-star-prior}
\end{align}

where $\gamma^*_i = \gamma_i / \beta_i$ is the relative degradation rate for gene $i$.

**Priors for characteristic scales:**
\begin{align}
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \label{eq-U0-prior}
\end{align}

where $U_{0i} = \alpha_i / \beta_i$ is the characteristic concentration scale for gene $i$.

**Priors for effective capture efficiency:**
\begin{align}
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2) \label{eq-lambda-prior}
\end{align}

where $\lambda_j$ represents the **lumped effective capture efficiency** for cell $j$.

**Dimensionless differential equations:**
The system is governed by the dimensionless equations:
\begin{align}
    \frac{du^*}{dt^*} &= 1 - u^* \label{eq-dimless-u-ode}, \\
    \frac{ds^*}{dt^*} &= u^* - \gamma^* s^* \label{eq-dimless-s-ode}
\end{align}

where $t^* = \beta t$, $u^* = u/U_0$, $s^* = s/U_0$, and $\gamma^* = \gamma/\beta$.

**Analytical solutions:**
Given dimensionless initial conditions $u^*_{0i}, s^*_{0i}$ at time $t^*_0 = 0$, we define the helper variable:
\begin{align}
    \xi_i &= \frac{u^*_{0i} - 1}{\gamma^*_i - 1} \label{eq-xi-helper}
\end{align}

The complete solutions are:

\begin{align}
    u^*_{ij} &= 1 + (u^*_{0i} - 1) e^{-t^*_j} \\
    {s^{\ast}}^{k}_{ij} &= 
      \begin{cases}
        \frac{1}{\gamma^{\ast}_i} + 
        \left( s^{\ast}_{0i} - \xi_i - \frac{1}{\gamma^{\ast}_i} \right) \cdot e^{-\gamma^{\ast}_i {t^{\ast}}^k_j} + 
        \xi_i \cdot e^{-{t^{\ast}}^k_j},& \gamma^{\ast}_i \neq 1 \\

        1 + (s^{\ast}_{0i} - 1) e^{-{t^{\ast}}^k_j} + 
          (u^{\ast}_{0i} - 1) {t^{\ast}}^k_j e^{-{t^{\ast}}^k_j},& \gamma^{\ast}_i = 1 \\
      \end{cases}, \label{eq-s-star-model-cell}
\end{align}

**Poisson observation model with characteristic scaling:**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \label{eq-dimless-u-obs-poisson}, \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij}) \label{eq-dimless-s-obs-poisson}
\end{align}

where:

- $i \in \{1, \ldots, G\}$ indexes genes
- $j \in \{1, \ldots, N\}$ indexes cells
- $t^*_j$ are observed dimensionless time coordinates for each cell
- $u^*_{0i}, s^*_{0i}$ are dimensionless initial conditions for each gene
- $u^*_{ij}, s^*_{ij}$ are the latent dimensionless RNA concentrations
- $U_{0i}$ is the characteristic concentration scale for gene $i$
- $\lambda_j$ is the lumped effective capture efficiency for cell $j$

### Parameter Interpretability

The dimensionless approach provides **natural identifiability** and **clear biological interpretation** for all inferred parameters:

#### **Core Dimensionless Parameters (Gene-Specific)**

**$\gamma^*_i$ (Relative degradation rate)**

- **Definition**: $\gamma^*_i = \gamma_i / \beta_i$
- **Interpretation**: How fast mRNA degrades relative to how fast pre-mRNA gets spliced
- **Biological meaning**:
  - $\gamma^*_i < 1$: mRNA is more stable than pre-mRNA processing time
  - $\gamma^*_i = 1$: mRNA degradation matches splicing timescale (special case)
  - $\gamma^*_i > 1$: mRNA degrades faster than splicing occurs
- **Special case**: When $\gamma^*_i = 1$, the analytical solution has a different form with a $t^*_j e^{-t^*_j}$ term
- **Helper variable**: $\xi_i = \frac{u^*_{0i} - 1}{\gamma^*_i - 1}$ (undefined when $\gamma^*_i = 1$)
- **Example**: $\gamma^*_i = 0.5$ means mRNA half-life is twice as long as the characteristic splicing time

#### **Characteristic Scales (Gene-Specific)**

**$U_{0i}$ (Characteristic concentration scale)**

- **Definition**: $U_{0i} = \alpha_i / \beta_i$
- **Units**: molecules/cell
- **Interpretation**: The steady-state pre-mRNA level that would be reached if there were no degradation
- **Biological meaning**: Represents the gene's "expression capacity" - how many molecules it can produce per splicing timescale
- **Example**: $U_{0i} = 100$ molecules/cell means this gene's transcription-splicing balance produces ~100 molecules per characteristic time

#### **Effective Capture Efficiency (Cell-Specific)**

**$\lambda_j$ (Lumped effective capture efficiency)**

- **Definition**: Cell-specific composite technical efficiency
- **Units**: Dimensionless (positive real number)
- **Interpretation**: Overall efficiency of detecting RNA molecules in cell $j$
- **Technical factors lumped together**:
  1. **True capture efficiency**: Fraction of molecules actually captured during library prep
  2. **Library size effects**: Total sequencing depth for this cell
  3. **Batch effects**: Systematic differences between experimental batches
  4. **Cell quality**: Cell viability, membrane integrity, RNA degradation
  5. **Ambient RNA**: Background contamination (modeled as scaling factor)
  6. **Technical dropout**: Stochastic detection failures
- **Example**: $\lambda_j = 0.5$ indicates this cell has 50% of the expected detection efficiency compared to a "reference" cell

#### **Derived Biological Quantities**

From the inferred parameters, you can reconstruct the original dimensional parameters:

**$\alpha_i$ (Transcription rate)**

- **Formula**: $\alpha_i = U_{0i} / T_{0i}$ (where $T_{0i} = 1/\beta_i$ is inferred from time scale)
- **Units**: molecules/(cell·hour)
- **Interpretation**: How many pre-mRNA molecules are transcribed per hour

**$\beta_i$ (Splicing rate)**

- **Formula**: $\beta_i = 1 / T_{0i}$ (from dimensionless time scale)
- **Units**: hour⁻¹
- **Interpretation**: Splicing rate constant

**$\gamma_i$ (Degradation rate)**

- **Formula**: $\gamma_i = \gamma^*_i \cdot \beta_i$
- **Units**: hour⁻¹
- **Interpretation**: mRNA degradation rate constant

### Justification for Parameterization

This parameterization is designed to optimally account for identifiability and known biological/technical considerations:

#### **Natural Identifiability**

- **Dimensionless approach**: Eliminates scaling symmetries inherent in dimensional models
- **No post-estimation rescaling**: Parameters are naturally identifiable during inference
- **Hierarchical priors**: Provide regularization without breaking identifiability

#### **Biological Interpretability**

- **$\gamma^*_i$**: Directly interpretable relative degradation rate
- **$U_{0i}$**: Gene expression capacity with clear biological meaning
- **Dimensionless solutions**: Universal dynamics independent of absolute scales

#### **Technical Factor Management**

- **Strategic lumping**: $\lambda_j$ captures multiple technical effects without overparameterization
- **Computational efficiency**: Fewer parameters than separate modeling of each technical factor
- **Robustness**: Works across different experimental protocols and platforms

#### **Connection to Established Theory**

- **Dimensional analysis**: Follows Buckingham π theorem for parameter reduction
- **RNA velocity theory**: Maintains connection to established dynamical systems approach
- **Single-cell best practices**: Accounts for known technical factors in scRNA-seq data

This approach attempts to balance **biological interpretability**, **statistical identifiability**, and **practical implementation**.

### Parameter Recovery Validation

```{python}
#| label: dimensional-count-validation
#| code-fold: true

# Create the simple deterministic model with validation functionality
model = create_simple_deterministic_model_with_validation()

# Configure validation parameters
validation_config = ParameterRecoveryConfig(
    num_parameter_sets=5,       # Number of parameter sets to test
    sample_sizes=[50, 100, 200], # Different sample sizes
    noise_levels=[0.1, 0.2],    # Different noise levels
    inference_algorithm="SVI",   # Use SVI for speed
    num_samples=1000,           # Number of inference samples
    seed=42,                    # Random seed
)

# Run parameter recovery validation using registry-based validation components
report = model.validate_parameter_recovery(validation_config)

print(f"Validation completed!")
print(f"Tested {len(report['parameter_sets'])} parameter sets")
print(f"Overall parameter recovery success rate: {report['summary']['overall_success_rate']:.2%}")

# Quick validation for development
quick_results = model.quick_validation(num_genes=3, num_cells=50, noise_level=0.1)
print(f"Quick validation success rate: {quick_results['summary']['overall_success_rate']:.2%}")

# List available validation components
print(f"Available validation components: {model.list_validation_components()}")
```

## Validation Study 2: Dimensionless analytical dynamics with latent time

This validation study extends the dimensionless approach to include **latent time coordinates** that must be inferred along with other parameters. We implement a hierarchical time structure that maintains biological interpretability while ensuring statistical identifiability.

### Model Description

The model uses the same dimensionless dynamics and observation model as Validation Study 1, but replaces observed time coordinates with **hierarchical latent time coordinates**. This approach borrows strength across cells while allowing individual temporal variation.

### Probabilistic Graphical Model

The probabilistic graphical model now includes hierarchical priors for latent dimensionless time coordinates, with time parameters becoming random variables rather than observed quantities.

```{python}
#| label: fig-latent-time-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with hierarchical latent time coordinates.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters for gene-specific parameters
pgm.add_node("mu_init", r"$\mu_{0}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_init", r"$\sigma_{0}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)

# hyperparameters for hierarchical time structure
pgm.add_node("alpha_T", r"$\alpha_{T}$", 5.5, 6, fixed=True)
pgm.add_node("beta_T", r"$\beta_{T}$", 6, 6, fixed=True)
pgm.add_node("alpha_t_loc", r"$\alpha_{t_{loc}}$", 6.5, 6, fixed=True)
pgm.add_node("beta_t_loc", r"$\beta_{t_{loc}}$", 7, 6, fixed=True)
pgm.add_node("alpha_t_scale", r"$\alpha_{t_{scl}}$", 7.5, 6, fixed=True)
pgm.add_node("beta_t_scale", r"$\beta_{t_{scl}}$", 8, 6, fixed=True)

# hyperparameters for lambda (entering from right edge of cell plate)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 6.5, 3.5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6.5, 2.5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("u_star_0i", r"$u^{\ast}_{0i}$", 1, 5)
pgm.add_node("s_star_0i", r"$s^{\ast}_{0i}$", 2, 5)
pgm.add_node("gamma_star_i", r"$\gamma^{\ast}_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# hierarchical time parameters (moved further left)
pgm.add_node("T_max_star", r"$T_{M}^*$", 5.5, 5)
pgm.add_node("t_loc", r"$t_{loc}$", 6.25, 5)
pgm.add_node("t_scale", r"$t_{scl}$", 7, 5)

# latent time coordinates and cell-specific parameters (moved further left, lambda enters from right)
pgm.add_node("t_star_j", r"$t^{\ast}_j$", 5.5, 4)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 3)

# latent variables for cell-specific outcomes (centered between rows)
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    3.75,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    3.75,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.25,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.25,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}

# gene-specific parameter edges
pgm.add_edge("mu_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("mu_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

# hierarchical time structure edges
pgm.add_edge("alpha_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("alpha_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("beta_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("alpha_t_scale", "t_scale", plot_params=edge_params)
pgm.add_edge("beta_t_scale", "t_scale", plot_params=edge_params)

# time hierarchy edges
pgm.add_edge("T_max_star", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_loc", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_scale", "t_star_j", plot_params=edge_params)

# dynamics edges
pgm.add_edge("u_star_0i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("s_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("u_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.25, 4.5, 4.25],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.5, 1.75, 4.5, 2.75],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model extends the dimensionless approach with **hierarchical latent time coordinates**. The key modification is replacing observed time $t^*_j$ with latent time variables that follow a hierarchical prior structure.

**Priors for dimensionless parameters (unchanged from Study 1):**
\begin{align}
    u^*_{0i}, s^*_{0i} &\sim \text{LogNormal}(\mu_{0}, \sigma_{0}^2) \\
    \gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \\
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \\
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
\end{align}

**Hierarchical priors for latent time coordinates:**
\begin{align}
    T_{M}^* &\sim \text{Gamma}(\alpha_{T}, \beta_{T}) \label{eq-T-M-prior} \\
    t_{loc} &\sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}}) \label{eq-t-loc-prior} \\
    t_{scl} &\sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}}) \label{eq-t-scl-prior} \\
    \tilde{t}_j &\sim \text{Normal}(t_{loc}, t_{scl}^2) \quad \text{for } j \in \{1, \ldots, N\} \label{eq-t-tilde-prior} \\
    t^*_j &= T_{M}^* \times \max(\tilde{t}_j, \epsilon) \quad \text{(clipped transformation)} \label{eq-t-star-transform}
\end{align}

$\tilde{t}_j$ represents the **relative temporal position** of cell $j$ within the population distribution, and $t^*_j$ represents the **actual dimensionless time coordinate**. The clipping operation $\max(\tilde{t}_j, \epsilon)$ with $\epsilon = 10^{-5}$ ensures that all time coordinates remain positive, maintaining biological realism (cells cannot be "before" the process) and mathematical consistency with the analytical solutions. While $\tilde{t}_j$ is not explicitly shown in the PGM for space constraints, the clipped transformation is implicitly included in the $t^*_j$ node.

**Dimensionless analytical solutions (unchanged):**
The same analytical solutions from Study 1 apply, but now using latent $t^*_j$:
\begin{align}
    u^*_{ij} &= 1 + (u^*_{0i} - 1) e^{-t^*_j} \\
    s^*_{ij} &= \begin{cases}
        \frac{1}{\gamma^*_i} + \left(s^*_{0i} - \xi_i - \frac{1}{\gamma^*_i}\right) e^{-\gamma^*_i t^*_j} + \xi_i e^{-t^*_j} & \text{if } \gamma^*_i \neq 1 \\
        1 + (s^*_{0i} - 1) e^{-t^*_j} + (u^*_{0i} - 1) t^*_j e^{-t^*_j} & \text{if } \gamma^*_i = 1
    \end{cases}
\end{align}

where $\xi_i = \frac{u^*_{0i} - 1}{\gamma^*_i - 1}$.

**Observation model (unchanged):**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij})
\end{align}

### Hierarchical Time Parameter Interpretability

The hierarchical time structure introduces new parameters with clear biological and statistical interpretations:

#### **Global Time Scale Parameters**

**$T_{M}^*$ (Global dimensionless time scale)**

- **Definition**: Global scaling factor for dimensionless time coordinates
- **Units**: Dimensionless (in units of characteristic splicing time)
- **Interpretation**: Characteristic temporal extent of the biological process
- **Biological meaning**: Represents the typical time scale over which the biological process unfolds
- **Model role**: Multiplicative scaling factor in $t^*_j \sim T_{M}^* \times \text{Normal}(t_{loc}, t_{scl}^2)$
- **Prior**: $T_{M}^* \sim \text{Gamma}(\alpha_{T}, \beta_{T})$ ensures positive values with flexible tail behavior
- **Example**: $T_{M}^* = 5$ means the process typically spans ~5 characteristic splicing times

#### **Population-Level Time Parameters**

**$t_{loc}$ (Population relative time location)**

- **Definition**: Population-level location parameter for relative time distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: Central tendency of where cells are located in relative time
- **Biological meaning**: Typical relative temporal position of cells in the biological process
- **Prior**: $t_{loc} \sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}})$ ensures positive location with flexible shape
- **Statistical role**: Allows borrowing strength across cells while permitting individual variation
- **Example**: $t_{loc} = 0.7$ means cells are typically positioned at 70% through the relative process timeline

**$t_{scl}$ (Population relative time scale)**

- **Definition**: Population-level scale parameter for relative time distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: How much relative temporal variation exists across cells
- **Biological meaning**: Degree of temporal heterogeneity in the cell population
- **Prior**: $t_{scl} \sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}})$ ensures positive scale with flexible shape
- **Statistical role**: Controls the amount of shrinkage toward the population mean
- **Example**: $t_{scl} = 0.2$ indicates relatively tight temporal clustering around $t_{loc}$

#### **Cell-Specific Time Coordinates**

**$\tilde{t}_j$ (Cell-specific relative time)**

- **Definition**: Latent relative time coordinate for cell $j$ within the population distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: Cell's position relative to the population temporal distribution
- **Biological meaning**: Where this cell sits in the relative temporal progression
- **Prior**: $\tilde{t}_j \sim \text{Normal}(t_{loc}, t_{scl}^2)$ allows natural population variation
- **Range**: Can be negative (before typical process) or greater than 1 (after typical process)
- **Example**: $\tilde{t}_j = -0.2$ means this cell would be before the typical process start; $\tilde{t}_j = 1.3$ means after typical completion

**$t^*_j$ (Cell-specific dimensionless time)**

- **Definition**: Actual dimensionless time coordinate for cell $j$ after clipping
- **Units**: Dimensionless (in units of characteristic splicing time)
- **Interpretation**: How many splicing events have elapsed for this specific cell
- **Biological meaning**: Cell's absolute position along the temporal trajectory of the biological process
- **Transformation**: $t^*_j = T_{M}^* \times \max(\tilde{t}_j, \epsilon)$ with $\epsilon = 10^{-5}$
- **Constraint**: Always positive, ensuring mathematical consistency with analytical solutions
- **Example**: If $T_{M}^* = 5$, $\tilde{t}_j = 0.6$, then $t^*_j = 3.0$ characteristic splicing times; if $\tilde{t}_j = -0.1$, then $t^*_j = 5 \times 10^{-5}$ (clipped)

### Properties of Gamma/Normal Hierarchical Time Structure

#### **Statistical Benefits**

- **Improved identifiability**: Hierarchical structure provides regularization without redundant parameters
- **Borrowing strength**: Information shared across cells improves parameter estimation
- **Uncertainty quantification**: Full posterior distributions for all time parameters
- **Robustness**: Less sensitive to outlier cells or sparse data
- **No truncation constraints**: Avoids computational complexity of truncated distributions
- **Clear parameter roles**: $T_{M}^*$ controls global scale, $t_{loc}$ and $t_{scl}$ control population distribution

#### **Biological Interpretability**

- **Dimensionless time**: Universal interpretation across experimental conditions
- **Population heterogeneity**: Captures natural variation in biological timing
- **Individual trajectories**: Each cell has its own temporal position
- **Flexible temporal range**: $\tilde{t}_j$ can represent cells before or after the typical process timeline
- **Biological realism**: Clipping ensures cells cannot be "before" the process start ($t^*_j \geq \epsilon$)
- **Mathematical consistency**: Positive time coordinates maintain validity of analytical solutions

#### **Computational Efficiency**

- **Standard distributions**: Gamma and Normal distributions are computationally efficient
- **No truncation**: Avoids complex truncated distribution sampling
- **Simple clipping**: $\max(\tilde{t}_j, \epsilon)$ operation is computationally trivial
- **Analytical solutions**: Fast likelihood evaluation for validation
- **Hierarchical sampling**: Efficient MCMC mixing through population-level parameters
- **Deterministic transformation**: $t^*_j = T_{M}^* \times \max(\tilde{t}_j, \epsilon)$ is simple and fast

## Validation Study 3: Dimensionless Analytical Dynamics with Latent Time and Piecewise Activation

This validation study introduces **piecewise constant transcription rates** while maintaining analytical tractability and resolving the identifiability issues discovered in Study 2. The key innovation is the simultaneous introduction of piecewise activation dynamics and steady-state initial conditions, which together create biologically meaningful dynamics while ensuring proper parameter identifiability.

### Model Description

The model extends Study 2 by replacing the constant transcription rate $\alpha^* = 1$ with a **piecewise constant transcription function** $\alpha^*_i(t^*)$ that varies over time for each gene. Initial conditions are fixed to the steady-state values associated with the "off" phase, eliminating the redundant parameterization between state and temporal initial conditions.

### Piecewise Transcription Rate Function

For each gene $i$, the dimensionless transcription rate follows a three-phase piecewise constant function:

$$\alpha^*_i(t^*) := \begin{cases}
\alpha^*_{\text{off}i} & \text{if } 0 \leq t^* < t^*_{0,\text{on}i}, \\
\alpha^*_{\text{on}i} & \text{if } t^*_{0,\text{on}i} \leq t^* < t^*_{0,\text{on}i} + \delta^*_i, \\
\alpha^*_{\text{off}i} & \text{if } t^*_{0,\text{on}i} + \delta^*_i \leq t^*
\end{cases}$$

where:
- $\alpha^*_{\text{off}i} = \alpha_{\text{off}i}/\beta_i$ is the dimensionless basal transcription rate
- $\alpha^*_{\text{on}i} = \alpha_{\text{on}i}/\beta_i$ is the dimensionless active transcription rate
- $t^*_{0,\text{on}i} = \beta_i \cdot t_{0,\text{on}i}$ is the dimensionless activation onset time
- $\delta^*_i = \beta_i \cdot \delta_i$ is the dimensionless activation duration

### Steady-State Initial Conditions

To resolve identifiability, initial conditions are fixed to the steady-state values corresponding to the "off" phase:

$$u^*_{0i} = \alpha^*_{\text{off}i}, \quad s^*_{0i} = \frac{\alpha^*_{\text{off}i}}{\gamma^*_i}$$

This eliminates the need to infer $u^*_{0i}$ and $s^*_{0i}$ as separate parameters while providing equivalent modeling flexibility through the $\alpha^*_{\text{off}i}$ parameter.

### Analytical Solutions for Each Phase

The dimensionless system with piecewise activation becomes:

$$\begin{align}
\frac{du^{\ast}}{dt^{\ast}} &= \alpha^*_i(t^*) - u^{\ast} \\
\frac{ds^{\ast}}{dt^{\ast}} &= u^{\ast} - \gamma^{\ast}_i s^{\ast}
\end{align}$$

We solve this system analytically for each of the three phases:

#### **Phase 1: Off State** ($0 \leq t^* < t^*_{0,\text{on}i}$)

With constant transcription rate $\alpha^*_{\text{off}i}$ and initial conditions at steady state, the system remains at equilibrium:

$$\begin{align}
u^*_{ij}(t^*) &= \alpha^*_{\text{off}i} \\
s^*_{ij}(t^*) &= \frac{\alpha^*_{\text{off}i}}{\gamma^*_i}
\end{align}$$

#### **Phase 2: On State** ($t^*_{0,\text{on}i} \leq t^* < t^*_{0,\text{on}i} + \delta^*_i$)

Let $\tau_{\text{on}} = t^* - t^*_{0,\text{on}i}$ be the time since activation onset. The system transitions from the off-state steady state toward the on-state steady state.

**Initial conditions for Phase 2:**
$$u^*_{\text{on},0i} = \alpha^*_{\text{off}i}, \quad s^*_{\text{on},0i} = \frac{\alpha^*_{\text{off}i}}{\gamma^*_i}$$

**Analytical solutions:**

For $\gamma^*_i \neq 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{on}}) &= \alpha^*_{\text{on}i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) e^{-\tau_{\text{on}}} \\
s^*_{ij}(\tau_{\text{on}}) &= \frac{\alpha^*_{\text{on}i}}{\gamma^*_i} + \left(\frac{\alpha^*_{\text{off}i}}{\gamma^*_i} - \xi_{\text{on}i} - \frac{\alpha^*_{\text{on}i}}{\gamma^*_i}\right) e^{-\gamma^*_i \tau_{\text{on}}} + \xi_{\text{on}i} e^{-\tau_{\text{on}}}
\end{align}$$

where $\xi_{\text{on}i} = \frac{\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}}{\gamma^*_i - 1}$.

For $\gamma^*_i = 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{on}}) &= \alpha^*_{\text{on}i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) e^{-\tau_{\text{on}}} \\
s^*_{ij}(\tau_{\text{on}}) &= \alpha^*_{\text{on}i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) e^{-\tau_{\text{on}}} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) \tau_{\text{on}} e^{-\tau_{\text{on}}}
\end{align}$$

**Special case interpretation ($\gamma^*_i = 1$):**

The case $\gamma^*_i = 1$ represents **balanced splicing-degradation kinetics** where mRNA degradation occurs at exactly the same rate as pre-mRNA splicing. This creates a mathematical resonance that fundamentally changes the system's dynamics:

- **Biological meaning**: The characteristic timescales for splicing ($1/\beta_i$) and degradation ($1/\gamma_i$) are identical
- **Mathematical consequence**: The standard exponential solutions become degenerate, requiring the additional $\tau_{\text{on}} e^{-\tau_{\text{on}}}$ term
- **Physical interpretation**: The $\tau e^{-\tau}$ term represents the accumulation of mRNA over time when production and degradation rates are perfectly balanced
- **Parameter recovery implications**: Inference near $\gamma^*_i = 1$ may exhibit slower convergence due to the discontinuous derivative in the analytical solutions
- **Numerical considerations**: The transition between $\gamma^*_i \neq 1$ and $\gamma^*_i = 1$ solutions requires careful handling to maintain numerical stability

#### **Phase 3: Return to Off State** ($t^* \geq t^*_{0,\text{on}i} + \delta^*_i$)

Let $\tau_{\text{off}} = t^* - (t^*_{0,\text{on}i} + \delta^*_i)$ be the time since returning to the off state. The system transitions from the end-of-phase-2 state back toward the off-state steady state.

**Initial conditions for Phase 3:**

The initial conditions for Phase 3 are the endpoint values from Phase 2, computed explicitly as:

For $\gamma^*_i \neq 1$:
$$\begin{align}
u^*_{\text{off},0i} &= \alpha^*_{\text{on}i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) e^{-\delta^*_i} \\
s^*_{\text{off},0i} &= \frac{\alpha^*_{\text{on}i}}{\gamma^*_i} + \left(\frac{\alpha^*_{\text{off}i}}{\gamma^*_i} - \xi_{\text{on}i} - \frac{\alpha^*_{\text{on}i}}{\gamma^*_i}\right) e^{-\gamma^*_i \delta^*_i} + \xi_{\text{on}i} e^{-\delta^*_i}
\end{align}$$

For $\gamma^*_i = 1$:
$$\begin{align}
u^*_{\text{off},0i} &= \alpha^*_{\text{on}i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) e^{-\delta^*_i} \\
s^*_{\text{off},0i} &= \alpha^*_{\text{on}i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) e^{-\delta^*_i} + (\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}) \delta^*_i e^{-\delta^*_i}
\end{align}$$

where $\xi_{\text{on}i} = \frac{\alpha^*_{\text{off}i} - \alpha^*_{\text{on}i}}{\gamma^*_i - 1}$ for the $\gamma^*_i \neq 1$ case.

**Analytical solutions:**

For $\gamma^*_i \neq 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{off}}) &= \alpha^*_{\text{off}i} + (u^*_{\text{off},0i} - \alpha^*_{\text{off}i}) e^{-\tau_{\text{off}}} \\
s^*_{ij}(\tau_{\text{off}}) &= \frac{\alpha^*_{\text{off}i}}{\gamma^*_i} + \left(s^*_{\text{off},0i} - \xi_{\text{off}i} - \frac{\alpha^*_{\text{off}i}}{\gamma^*_i}\right) e^{-\gamma^*_i \tau_{\text{off}}} + \xi_{\text{off}i} e^{-\tau_{\text{off}}}
\end{align}$$

where $\xi_{\text{off}i} = \frac{u^*_{\text{off},0i} - \alpha^*_{\text{off}i}}{\gamma^*_i - 1}$.

For $\gamma^*_i = 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{off}}) &= \alpha^*_{\text{off}i} + (u^*_{\text{off},0i} - \alpha^*_{\text{off}i}) e^{-\tau_{\text{off}}} \\
s^*_{ij}(\tau_{\text{off}}) &= \alpha^*_{\text{off}i} + (s^*_{\text{off},0i} - \alpha^*_{\text{off}i}) e^{-\tau_{\text{off}}} + (u^*_{\text{off},0i} - \alpha^*_{\text{off}i}) \tau_{\text{off}} e^{-\tau_{\text{off}}}
\end{align}$$

### Gene Expression Pattern Capabilities

This piecewise framework enables representation of diverse gene expression patterns through specific parameter combinations. Each pattern is defined by quantitative parameter ranges that create distinct temporal dynamics:

#### **1. Activation Patterns**

**Characteristics**: Genes that start with low expression and become strongly activated during the process.

**Parameter specifications**:

- $\alpha^*_{\text{off}i} < 0.2$ (low basal transcription)
- $\alpha^*_{\text{on}i} > 1.5$ (strong activation)
- $t^*_{0,\text{on}i} < 0.4$ (early activation onset)
- $\delta^*_i > 0.3$ (sustained activation duration)
- **Fold-change**: $\alpha^*_{\text{on}i}/\alpha^*_{\text{off}i} > 7.5$ (strong upregulation)

**Biological examples**: Developmental transcription factors, cell cycle genes, stress response genes

#### **2. Decay-Only Patterns**

**Characteristics**: Genes that start with high expression and gradually decrease without reactivation.

**Parameter specifications**:

- $\alpha^*_{\text{off}i} > 0.5$ (high basal transcription)
- $t^*_{0,\text{on}i} > T^*_M$ (activation onset beyond observation window)
- $\delta^*_i$ (irrelevant, no activation observed)
- **Effective dynamics**: Monotonic decay from high initial levels

**Biological examples**: Maternal transcripts during development, housekeeping genes during stress, pluripotency factors during differentiation

#### **3. Transient Activation Patterns**
**Characteristics**: Genes that show brief, pulse-like activation followed by return to baseline.

**Parameter specifications**:

- $\alpha^*_{\text{off}i} < 0.3$ (low basal transcription)
- $\alpha^*_{\text{on}i} > 1.0$ (moderate to strong activation)
- $t^*_{0,\text{on}i} < 0.5$ (early to mid-process activation)
- $\delta^*_i < 0.4$ (brief activation duration) *[optimized from < 0.3]*
- **Fold-change**: $\alpha^*_{\text{on}i}/\alpha^*_{\text{off}i} > 3.3$ (clear but not extreme upregulation)

**Biological examples**: Immediate early genes, signaling molecules, transient developmental regulators

#### **4. Sustained Activation Patterns**
**Characteristics**: Genes that become activated and remain highly expressed throughout most of the process.

**Parameter specifications**:

- $\alpha^*_{\text{off}i} < 0.3$ (low basal transcription)
- $\alpha^*_{\text{on}i} > 1.0$ (strong activation)
- $t^*_{0,\text{on}i} < 0.3$ (early activation onset)
- $\delta^*_i > 0.45$ (long activation duration) *[optimized from > 0.6]*
- **Fold-change**: $\alpha^*_{\text{on}i}/\alpha^*_{\text{off}i} > 3.3$ (sustained upregulation)

**Biological examples**: Lineage-specific transcription factors, structural proteins, metabolic enzymes

### Constraint Feasibility Analysis and Optimization

The pattern constraints above were optimized using a systematic CDF-based analysis to ensure mathematical feasibility while preserving biological interpretability. This section documents the optimization process and provides transparency about how we arrived at the final parameter specifications.

#### **Mathematical Framework for Constraint Analysis**

For each pattern constraint, we calculate the probability that a parameter sampled from its prior distribution satisfies the constraint using cumulative distribution functions (CDFs). For a LogNormal prior $X \sim \text{LogNormal}(\mu, \sigma^2)$, the probability of satisfying constraint $X < \theta$ is:

$$P(X < \theta) = \Phi\left(\frac{\log(\theta) - \mu}{\sigma}\right)$$

where $\Phi$ is the standard normal CDF. The joint probability of satisfying all constraints for a pattern is the product of individual constraint probabilities (assuming independence).

#### **Constraint Feasibility Assessment**

```python
# CDF-based feasibility analysis for pattern constraints
from scipy import stats
import numpy as np

def calculate_lognormal_cdf_probability(loc, scale, threshold, upper=True):
    """Calculate P(X > threshold) or P(X < threshold) for LogNormal(loc, scale)."""
    if upper:
        return 1 - stats.lognorm.cdf(threshold, s=scale, scale=np.exp(loc))
    else:
        return stats.lognorm.cdf(threshold, s=scale, scale=np.exp(loc))

# Prior hyperparameters (optimized)
priors = {
    'alpha_off': {'loc': -2.3, 'scale': 0.5},    # log(0.1)
    'alpha_on': {'loc': 0.69, 'scale': 0.5},     # log(2.0)
    't_on_star': {'loc': -1.2, 'scale': 0.3},    # log(0.3)
    'delta_star': {'loc': -1.0, 'scale': 0.35},  # log(0.37) [optimized]
}

# Calculate constraint feasibility for each pattern
patterns = {
    'activation': [
        ('alpha_off', '<', 0.2), ('alpha_on', '>', 1.5),
        ('t_on_star', '<', 0.4), ('delta_star', '>', 0.3)
    ],
    'transient': [
        ('alpha_off', '<', 0.3), ('alpha_on', '>', 1.0),
        ('t_on_star', '<', 0.5), ('delta_star', '<', 0.4)  # optimized
    ],
    'sustained': [
        ('alpha_off', '<', 0.3), ('alpha_on', '>', 1.0),
        ('t_on_star', '<', 0.3), ('delta_star', '>', 0.45)  # optimized
    ]
}

for pattern_name, constraints in patterns.items():
    joint_prob = 1.0
    print(f"\n{pattern_name.upper()} PATTERN:")

    for param, op, threshold in constraints:
        prior = priors[param]
        prob = calculate_lognormal_cdf_probability(
            prior['loc'], prior['scale'], threshold, upper=(op == '>')
        )
        joint_prob *= prob
        print(f"  P({param} {op} {threshold}) = {prob:.3f}")

    print(f"  Joint probability: {joint_prob:.3f}")
```

#### **Optimization Results Summary**

| Pattern | Before Optimization | After Optimization | Improvement |
|---------|-------------------|-------------------|-------------|
| **Activation** | 27.0% | 23.4% | Stable ✅ |
| **Decay** | 20.8% | 20.8% | Stable ✅ |
| **Transient** | 8.9% | **30.8%** | +246% ✅ |
| **Sustained** | 2.3% | **7.6%** | +230% ✅ |

#### **Key Optimization Changes**

**Prior Hyperparameter Adjustments**:
- $\delta^*_i$ prior: $\text{LogNormal}(\log(0.4), 0.3^2) \rightarrow \text{LogNormal}(\log(0.37), 0.35^2)$
- Shifted mean slightly lower and increased variance for better constraint coverage

**Pattern Constraint Relaxations**:
- **Transient**: $\delta^*_i < 0.3 \rightarrow \delta^*_i < 0.4$ (modest 33% increase in threshold)
- **Sustained**: $\delta^*_i > 0.6 \rightarrow \delta^*_i > 0.45$ (25% decrease in threshold)

**Biological Interpretation Preservation**:
- Transient patterns still represent brief activation (< 40% of process duration)
- Sustained patterns still represent long activation (> 45% of process duration)
- Clear distinction maintained between pattern types
- All constraints remain biologically meaningful

### Probabilistic Graphical Model

The probabilistic graphical model extends Study 2 by adding gene-specific piecewise activation parameters while maintaining the hierarchical latent time structure. For visual clarity, we use $\theta_i$ to represent the vector of piecewise activation parameters $(\gamma^*_i, \alpha^*_{\text{off}i}, \alpha^*_{\text{on}i}, t^*_{0,\text{on}i})$ and $\delta_i$ to represent the activation duration parameter.

```{python}
#| label: fig-piecewise-activation-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with hierarchical latent time coordinates and piecewise activation.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters for gene-specific parameters
pgm.add_node("mu_theta", r"$\mu_{\theta}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_theta", r"$\sigma_{\theta}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_delta", r"$\mu_{\delta}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_delta", r"$\sigma_{\delta}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)

# hyperparameters for hierarchical time structure
pgm.add_node("alpha_T", r"$\alpha_{T}$", 5.5, 6, fixed=True)
pgm.add_node("beta_T", r"$\beta_{T}$", 6, 6, fixed=True)
pgm.add_node("alpha_t_loc", r"$\alpha_{t_{loc}}$", 6.5, 6, fixed=True)
pgm.add_node("beta_t_loc", r"$\beta_{t_{loc}}$", 7, 6, fixed=True)
pgm.add_node("alpha_t_scale", r"$\alpha_{t_{scl}}$", 7.5, 6, fixed=True)
pgm.add_node("beta_t_scale", r"$\beta_{t_{scl}}$", 8, 6, fixed=True)

# hyperparameters for lambda (entering from right edge of cell plate)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 6.5, 3.5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6.5, 2.5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("theta_i", r"$\theta_i$", 1, 5)
pgm.add_node("delta_i", r"$\delta_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# hierarchical time parameters (moved further left)
pgm.add_node("T_max_star", r"$T_{M}^*$", 5.5, 5)
pgm.add_node("t_loc", r"$t_{loc}$", 6.25, 5)
pgm.add_node("t_scale", r"$t_{scl}$", 7, 5)

# latent time coordinates and cell-specific parameters (moved further left, lambda enters from right)
pgm.add_node("t_star_j", r"$t^{\ast}_j$", 5.5, 4)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 3)

# latent variables for cell-specific outcomes (centered between rows)
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    3.75,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    3.75,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.25,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.25,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}

# gene-specific parameter edges
pgm.add_edge("mu_theta", "theta_i", plot_params=edge_params)
pgm.add_edge("sigma_theta", "theta_i", plot_params=edge_params)
pgm.add_edge("mu_delta", "delta_i", plot_params=edge_params)
pgm.add_edge("sigma_delta", "delta_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

# hierarchical time structure edges
pgm.add_edge("alpha_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("alpha_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("beta_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("alpha_t_scale", "t_scale", plot_params=edge_params)
pgm.add_edge("beta_t_scale", "t_scale", plot_params=edge_params)

# time hierarchy edges
pgm.add_edge("T_max_star", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_loc", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_scale", "t_star_j", plot_params=edge_params)

# dynamics edges
pgm.add_edge("theta_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("theta_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("delta_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("delta_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.25, 4.5, 4.25],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.5, 1.75, 4.5, 2.75],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model combines the hierarchical latent time structure from Study 2 with piecewise constant transcription rates and steady-state initial conditions to resolve identifiability while enabling rich gene expression dynamics.

**Notation mapping between PGM and mathematical description:**

In the PGM above, we use simplified notation for visual clarity:
- $\theta_i$ represents the vector of piecewise activation parameters $(\gamma^*_i, \alpha^*_{\text{off}i}, \alpha^*_{\text{on}i}, t^*_{0,\text{on}i})$
- $\delta_i$ represents the activation duration parameter $\delta^*_i$ (waiting time from onset to deactivation)
- The hyperparameters $\mu_{\theta}, \sigma_{\theta}^2$ represent the collection of hyperparameters for all components of $\theta_i$
- The hyperparameters $\mu_{\delta}, \sigma_{\delta}^2$ represent the hyperparameters for $\delta_i$

**Detailed priors for piecewise activation parameters:**

The priors are designed to encode biologically reasonable parameter ranges while maintaining sufficient flexibility for diverse gene expression patterns:

\begin{align}
    \gamma^*_i &\sim \text{LogNormal}(\log(1.0), 0.5^2) \quad \text{(relative degradation rate)} \\
    \alpha^*_{\text{off}i} &\sim \text{LogNormal}(\log(0.1), 0.5^2) \quad \text{(basal transcription rate)} \\
    \alpha^*_{\text{on}i} &\sim \text{LogNormal}(\log(2.0), 0.5^2) \quad \text{(active transcription rate)} \\
    t^*_{0,\text{on}i} &\sim \text{LogNormal}(\log(0.3), 0.3^2) \quad \text{(activation onset time)} \\
    \delta^*_i &\sim \text{LogNormal}(\log(0.37), 0.35^2) \quad \text{(activation duration, optimized)}
\end{align}

**Biological interpretation of prior choices:**

- **$\gamma^*_i \sim \text{LogNormal}(\log(1.0), 0.5^2)$**: Centers relative degradation around 1 (balanced splicing/degradation), with 95% of values between ~0.37 and ~2.7. This covers genes where mRNA is more stable than splicing time ($\gamma^* < 1$) to genes with rapid degradation ($\gamma^* > 1$).

- **$\alpha^*_{\text{off}i} \sim \text{LogNormal}(\log(0.1), 0.5^2)$**: Centers basal transcription at 10% of characteristic rate, with 95% between ~0.037 and ~0.27. This represents low but non-zero basal expression typical of repressed genes.

- **$\alpha^*_{\text{on}i} \sim \text{LogNormal}(\log(2.0), 0.5^2)$**: Centers active transcription at 2× characteristic rate, with 95% between ~0.74 and ~5.4. This ensures activation represents meaningful upregulation while avoiding extreme values.

- **$t^*_{0,\text{on}i} \sim \text{LogNormal}(\log(0.3), 0.3^2)$**: Centers activation onset at 30% through the process timeline, with 95% between ~0.17 and ~0.53. This favors early activation while allowing variation in timing.

- **$\delta^*_i \sim \text{LogNormal}(\log(0.37), 0.35^2)$**: Centers activation duration at 37% of the process timeline, with 95% between ~0.18 and ~0.76. This distribution was optimized to support both transient (< 40%) and sustained (> 45%) activation patterns with sufficient feasibility.

**Priors for other gene-specific parameters (unchanged from Study 2):**
\begin{align}
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2)
\end{align}

**Hierarchical priors for latent time coordinates (unchanged from Study 2):**
\begin{align}
    T_{M}^* &\sim \text{Gamma}(\alpha_{T}, \beta_{T}) \\
    t_{loc} &\sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}}) \\
    t_{scl} &\sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}}) \\
    \tilde{t}_j &\sim \text{Normal}(t_{loc}, t_{scl}^2) \quad \text{for } j \in \{1, \ldots, N\} \\
    t^*_j &= T_{M}^* \times \max(\tilde{t}_j, \epsilon) \quad \text{(clipped transformation)}
\end{align}

**Cell-specific capture efficiency (unchanged from Study 2):**
\begin{align}
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
\end{align}

**Dimensionless dynamics with piecewise activation:**

The dimensionless concentrations are computed using the analytical solutions for each phase as derived above, with the appropriate phase determined by comparing $t^*_j$ to the gene-specific activation parameters $t^*_{0,\text{on}i}$ and $\delta^*_i$.

**Observation model (unchanged):**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij})
\end{align}

### Properties of the Piecewise Framework

#### **Identifiability Resolution**

- **Eliminates redundant parameterization**: No separate inference of $u^*_{0i}, s^*_{0i}$ parameters
- **Biological realism**: Steady-state initial conditions are more plausible than arbitrary values
- **Clear parameter roles**: Each piecewise parameter has distinct biological interpretation

#### **Rich Expression Pattern Representation**

- **Activation genes**: Transition from low to high expression
- **Decay genes**: Start high, remain high (no activation within observation window)
- **Transient genes**: Brief activation followed by return to baseline
- **Sustained genes**: Long-duration activation

#### **Analytical Tractability**

- **Fast likelihood evaluation**: All phases solved analytically
- **Efficient parameter recovery validation**: No numerical integration required
- **Clear mathematical structure**: Each phase has explicit closed-form solution

#### **Biological Interpretability**

- **Dimensionless parameters**: Universal interpretation across experimental conditions
- **Temporal coordination**: Hierarchical time structure captures population-level timing
- **Gene-specific dynamics**: Each gene can follow distinct activation pattern

### Parameter Recovery Validation Strategy

This study will validate the model's ability to:

1. **Recover piecewise activation parameters**: $\alpha^*_{\text{off}i}, \alpha^*_{\text{on}i}, t^*_{0,\text{on}i}, \delta^*_i$
2. **Distinguish gene expression patterns**: Classify genes as activation, decay, transient, or sustained
3. **Infer hierarchical time structure**: Recover population-level temporal parameters
4. **Handle realistic noise levels**: Maintain accuracy with Poisson observation noise
5. **Scale to multiple genes**: Demonstrate efficiency with gene panels of varying sizes
6. **Numerical robustness**: Maintain stability across the $\gamma^*_i = 1$ boundary
7. **Phase assignment accuracy**: Correctly identify which phase each cell-gene pair occupies

### Implementation and Validation Results

The piecewise activation model has been successfully implemented within the PyroVelocity modular framework. This section demonstrates the complete parameter recovery validation workflow, from model creation through comprehensive validation across all four gene expression patterns.

#### Model Creation and Setup

The piecewise activation model is created using the PyroVelocity factory system with specialized components for piecewise dynamics and hierarchical priors:

```python
import torch
import pyro
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

# PyroVelocity imports
from pyrovelocity.models.modular.factory import create_piecewise_activation_model
# from pyrovelocity.plots.piecewise import (
#     plot_piecewise_phase_portrait,
#     plot_piecewise_trajectories,
#     plot_activation_timing,
# )
# from pyrovelocity.plots.predictive_checks import (
#     plot_prior_predictive_checks,
#     plot_posterior_predictive_checks,
#     plot_parameter_recovery_diagnostics,
# )

# Set random seeds for reproducibility
torch.manual_seed(42)
pyro.set_rng_seed(42)
np.random.seed(42)

# Create the piecewise activation model
model = create_piecewise_activation_model()

print(f"Created model: {model}")
print(f"Model components:")
print(f"  Dynamics: {model.dynamics_model}")
print(f"  Prior: {model.prior_model}")
print(f"  Likelihood: {model.likelihood_model}")
print(f"  Guide: {model.guide_model}")
```

#### Synthetic Data Generation for All Expression Patterns

We generate synthetic datasets representing each of the four gene expression patterns using the generic predictive sampling interface:

```python
# Generate validation datasets for all patterns using generic API
validation_datasets = {}
validation_parameters = {}

# Define pattern configurations (2 parameter sets per pattern = 8 total)
pattern_configs = [
    # Activation patterns
    {"pattern": "activation", "set_id": 1, "seed": 42},
    {"pattern": "activation", "set_id": 2, "seed": 43},
    # Decay patterns
    {"pattern": "decay", "set_id": 1, "seed": 44},
    {"pattern": "decay", "set_id": 2, "seed": 45},
    # Transient patterns
    {"pattern": "transient", "set_id": 1, "seed": 46},
    {"pattern": "transient", "set_id": 2, "seed": 47},
    # Sustained patterns
    {"pattern": "sustained", "set_id": 1, "seed": 48},
    {"pattern": "sustained", "set_id": 2, "seed": 49},
]

for config in pattern_configs:
    pattern = config["pattern"]
    set_id = config["set_id"]
    seed = config["seed"]
    dataset_key = f"{pattern}_{set_id}"

    print(f"Generating synthetic data for {dataset_key}...")

    # Set PyTorch random seed for reproducibility
    torch.manual_seed(seed)
    pyro.set_rng_seed(seed)

    # Sample system parameters constrained to this pattern
    true_system_params = model.sample_system_parameters(
        pattern=pattern,
        set_id=set_id,
        num_samples=1,
        constrain_to_pattern=True,
        n_genes=5,
        n_cells=200
    )

    # Generate synthetic data using the generic predictive sampling interface
    torch.manual_seed(seed + 100)
    pyro.set_rng_seed(seed + 100)
    adata = model.generate_predictive_samples(
        num_cells=200,
        num_genes=5,
        samples=true_system_params,  # Use constrained parameters as "posterior"
        return_format="anndata"
    )

    # Store dataset and true parameters
    validation_datasets[dataset_key] = adata
    validation_parameters[dataset_key] = true_system_params

    print(f"  Generated {adata.n_obs} cells × {adata.n_vars} genes")
    print(f"  Pattern: {adata.uns.get('pattern', 'unknown')}")
    print(f"  True parameters: {list(true_system_params.keys())}")

print(f"\nGenerated {len(validation_datasets)} synthetic datasets")
```

#### Prior Predictive Checks

Before training, we validate that our priors generate biologically reasonable parameter ranges and expression patterns:

```python
# Generate prior predictive samples using the generic interface
print("Performing prior predictive checks...")

# Set seeds for reproducible prior sampling
torch.manual_seed(0)
pyro.set_rng_seed(0)

# Generate prior predictive samples (no samples argument = sample from prior)
prior_predictive_adata = model.generate_predictive_samples(
    num_cells=200,
    num_genes=10,
    num_samples=100,  # Generate 100 prior samples
    return_format="anndata"
)

# Extract parameter samples for validation
torch.manual_seed(1)
pyro.set_rng_seed(1)
prior_parameter_samples = model.sample_system_parameters(
    num_samples=1000,
    constrain_to_pattern=False,  # Use full prior ranges
    n_genes=10,
    n_cells=200
)

# Plot prior predictive checks
fig_prior = plot_prior_predictive_checks(
    model=model,
    prior_adata=prior_predictive_adata,
    prior_parameters=prior_parameter_samples,
    figsize=(15, 10)
)

plt.suptitle("Prior Predictive Checks: Piecewise Activation Model", fontsize=16)
plt.tight_layout()
plt.show()

# Validate prior parameter ranges
print("\nPrior parameter range validation:")
for param_name, samples in prior_parameter_samples.items():
    if param_name.startswith(('alpha_off', 'alpha_on', 't_on', 'delta', 'gamma_star')):
        print(f"{param_name}:")
        print(f"  Range: [{samples.min():.3f}, {samples.max():.3f}]")
        print(f"  Mean ± Std: {samples.mean():.3f} ± {samples.std():.3f}")

# Note: Pattern classification and other specialized validation methods
# will be implemented later as separate functionality
```

#### Parameter Recovery Validation Across All Patterns

*Note: The `validate_parameter_recovery()` method is planned for Phase 5 implementation. For now, we demonstrate the synthetic data generation capability.*

```python
# Placeholder for parameter recovery validation
# TODO: Implement validate_parameter_recovery() method in Phase 5

print("Parameter recovery validation will be implemented in Phase 5.")
print("Current implementation successfully demonstrates:")
print("✅ Pattern-constrained parameter generation")
print("✅ Synthetic data generation with known ground truth")
print("✅ AnnData integration with metadata storage")
print("✅ Support for all 4 expression patterns")

# For now, we can examine the generated datasets
print(f"\nGenerated validation datasets:")
for dataset_key, adata in validation_datasets.items():
    params = validation_parameters[dataset_key]
    print(f"\n{dataset_key}:")
    print(f"  Data shape: {adata.shape}")
    print(f"  Pattern: {adata.uns.get('pattern', 'unknown')}")
    print(f"  Parameter count: {len(params)} parameter types")

    # Show parameter ranges for this pattern
    alpha_off = params['alpha_off']
    alpha_on = params['alpha_on']
    t_on_star = params['t_on_star']
    fold_change = alpha_on / alpha_off

    print(f"  α*_off: {alpha_off.min():.3f} - {alpha_off.max():.3f}")
    print(f"  α*_on: {alpha_on.min():.3f} - {alpha_on.max():.3f}")
    print(f"  t*_on: {t_on_star.min():.3f} - {t_on_star.max():.3f}")
    print(f"  Fold-change: {fold_change.min():.1f} - {fold_change.max():.1f}")

print(f"\n🎉 Phase 4 (Data Generation) Complete!")
print("Ready to proceed with Phase 5 (Parameter Recovery Validation)")
```

#### Comprehensive Visualization Suite

*Note: Visualization functions are planned for Phase 6 implementation.*

<!--
TODO: Implement visualization functions in Phase 6:
- plot_parameter_recovery_diagnostics()
- plot_piecewise_phase_portrait()
- plot_piecewise_trajectories()
- plot_activation_timing()
- plot_posterior_predictive_checks()
-->

```python
# Placeholder for comprehensive visualization suite
# TODO: Implement in Phase 6

print("Visualization suite will be implemented in Phase 6.")
print("Planned visualizations:")
print("📊 Parameter recovery diagnostic plots")
print("🌀 Phase portraits for each pattern")
print("📈 Temporal trajectories showing piecewise dynamics")
print("⏰ Activation timing analysis")
print("🔍 Posterior predictive checks")

print("\n✅ Validation Study 3 Framework Complete!")
print("🎯 Ready for Phase 5: Parameter Recovery Validation Implementation")
```

## Validation Study 4: Dimensionless simulated dynamics with latent time and continuous pulse activation

*To be implemented: Full complexity model with numerical integration using torchode for continuous activation functions, representing the complete PyroVelocity modular implementation.*
