---
title: Parameter Recovery Validation
toc: true
number-sections: true
highlight-style: gruvbox
csl: ../../bibstyle.csl
lightbox: auto
format:
  html:
    html-math-method: mathjax
    include-in-header: ../../mathjax.html
format-links: [ipynb]
execute:
  freeze: true
  eval: true
  warning: false
  error: false
  cache: true
author:
  - name: Pyrovelocity Team
    email: team@pyrovelocity.net
abstract: |
  This notebook demonstrates parameter recovery validation for PyroVelocity models using the direct dimensionless approach,
  progressing from analytical solutions with observed time to numerical simulation with latent time coordinates.
  We focus on models that naturally avoid identifiability issues while maintaining biological interpretability,
  using hierarchical priors on characteristic scales and lumped effective capture efficiency.
  We illustrate how to systematically validate that probabilistic models can recover
  known parameters from synthetic data, which is essential before applying models
  to real-world data where true parameter values are unknown.
keywords: [single-cell transcriptomics, probabilistic modeling, model calibration, model validation, RNA velocity]
bibliography: ../../references.bib
jupyter:
  jupytext:
    cell_metadata_filter: all
    cell_metadata_json: true
    notebook_metadata_filter: all
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: 1.0
      jupytext_version: 1.16.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
  language_info:
    name: python
  rise:
    scroll: true
    theme: black
  toc-autonumbering: true
  toc-showcode: false
  toc-showmarkdowntxt: false
---

## Introduction

Parameter recovery validation is a critical step in validating probabilistic models before applying them to real data. This process involves:

1. **Generating synthetic data** using known parameter values
2. **Running inference** to recover parameters from the synthetic data
3. **Evaluating recovery performance**
4. **Assessing model identifiability**

This notebook demonstrates parameter recovery validation for PyroVelocity models using the dimensionless parameterization that naturally avoids identifiability issues while maintaining biological interpretability. We implement hierarchical priors on characteristic scales and lumped effective capture efficiency, progressing from analytical solutions with observed time to numerical simulation with latent time coordinates. For each model we include a graphical representation of the model's generative process as well as a mathematical description of the prior, observation model, and likelihood.

## Model Progression

We validate parameter recovery across a progression of **dimensionless models** that naturally avoid identifiability issues while maintaining biological interpretability. Each model builds complexity while preserving the core dimensionless parameterization.

### Dimensionless Analytical Dynamics with Observed Time

This model uses the direct dimensionless approach with analytical solutions:

- **Time coordinates**: Observed dimensionless time $t^*_j$
- **Dynamics**: Analytical dimensionless transcription-splicing-degradation solutions
- **Parameters**: $\gamma^*_i$ (relative degradation), $U_{0i}$ (characteristic scale), $\lambda_j$ (lumped capture efficiency)
- **Prior**: Log-normal hierarchical priors for all parameters
- **Observation Model**: Poisson counts scaled by characteristic scales and capture efficiency
- **Likelihood**: Poisson product distribution
- **Identifiability**: Naturally identifiable through dimensionless parameterization

### Dimensionless Analytical Dynamics with Latent Time

This model introduces latent dimensionless time coordinates:

- **Time coordinates**: Latent $t^*_j$ with hierarchical Gamma/Normal priors
- **Dynamics**: Same dimensionless analytical solutions
- **Parameters**: $\gamma^*_i$, $U_{0i}$, $\lambda_j$, plus hierarchical time structure ($T_{M}^*$, $t_{loc}$, $t_{scl}$)
- **Prior**: Gamma priors for time scales, Normal for relative positions
- **Observation Model**: Same Poisson scaling approach
- **Likelihood**: Poisson

### Dimensionless Analytical Dynamics with Latent Time and Piecewise Activation

This model extends the latent time framework with piecewise constant transcription rates:

- **Time coordinates**: Same hierarchical latent $t^*_j$ structure as previous model
- **Dynamics**: Piecewise constant transcription with three phases (off, on, return-to-off)
- **Parameters**: $\gamma^*_i$, $R_{\text{on},i}$ (fold-change), $t^*_{0,\text{on}i}$ (onset), $\delta^*_i$ (duration), plus hierarchical time structure
- **Key innovation**: Fixed reference state ($\alpha^*_{\text{off}i} = 1.0$) eliminates parameter redundancy
- **Enhanced patterns**: Supports pre-activation scenarios with negative onset times
- **Analytical solutions**: Closed-form solutions for all three phases, including $\gamma^*_i = 1$ special case
- **Biological realism**: Steady-state initial conditions and rich expression pattern representation
- **Observation Model**: Same Poisson scaling with characteristic scales and capture efficiency
- **Likelihood**: Poisson

## Parameter Recovery Validation Framework

```{python}
#| label: setup-imports
#| code-fold: true

import numpy as np
import torch
import pyro
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

# PyroVelocity imports
from pyrovelocity.models.modular.factory import (
    create_piecewise_activation_model,
    create_legacy_model2,
)
# from pyrovelocity.models.modular.components.validation import (
#     ParameterRecoveryConfig,
# )
from pyrovelocity.io.datasets import bifurcation_14

# Set random seeds for reproducibility
torch.manual_seed(42)
pyro.set_rng_seed(42)
np.random.seed(42)

print("Setup complete!")
```

## Dimensionless analytical dynamics with observed time {#sec-dimless-observed-time}

This validation study focuses on the **direct dimensionless approach** that naturally avoids identifiability issues while maintaining biological interpretability. We follow the theoretical foundation from our [Probabilistic inference in dynamical systems](../inferenceindynamicalsystems/index.qmd) concept guide, implementing hierarchical priors on characteristic scales and lumped effective capture efficiency.

### Model Description

We model the transcription-splicing-degradation system using the **direct dimensionless approach** that naturally avoids identifiability issues while maintaining biological interpretability. This approach fits the dimensionless model directly with hierarchical priors on characteristic scales, eliminating the need for post-estimation rescaling procedures.

The model generates count data for unspliced ($u$) and spliced ($s$) RNA molecules per cell, with dynamics governed by the dimensionless analytical solutions and observation model that scales back to dimensional counts through characteristic scales and effective capture efficiency.

### Probabilistic Graphical Model

The probabilistic graphical model represents the dimensionless transcription-splicing-degradation system with hierarchical priors on characteristic scales and lumped effective capture efficiency. The model directly fits dimensionless parameters while maintaining biological interpretability through characteristic scales.

```{python}
#| label: fig-count-model-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for the dimensionless transcription-splicing-degradation model with hierarchical priors on characteristic scales and lumped effective capture efficiency.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters
pgm.add_node("mu_init", r"$\mu_{0}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_init", r"$\sigma_{0}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 5.5, 5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6, 5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("u_star_0i", r"$u^{\ast}_{0i}$", 1, 5)
pgm.add_node("s_star_0i", r"$s^{\ast}_{0i}$", 2, 5)
pgm.add_node("gamma_star_i", r"$\gamma^{\ast}_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# cell-specific parameters (moved inside cell plate)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 4)

# latent variables for cell-specific outcomes
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    4,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    4,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "t_star_j",
    r"$t^{\ast}_j$",
    5.5,
    3.0,
    observed=True,
    shape="rectangle",
)
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.5,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.5,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}
pgm.add_edge("mu_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("mu_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

pgm.add_edge("u_star_0i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("s_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("u_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)

pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.4, 4.5, 4.2],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.0, 1.9, 5.0, 2.6],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model is defined by the following hierarchical structure using the **direct dimensionless approach**:

**Priors for dimensionless initial conditions:**
\begin{align}
    u^*_{0i}, s^*_{0i} &\sim \text{LogNormal}(\mu_{0}, \sigma_{0}^2) \label{eq-dimless-init-conds-priors}
\end{align}

**Priors for dimensionless kinetic parameters:**
\begin{align}
    \gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \label{eq-gamma-star-prior}
\end{align}

where $\gamma^*_i = \gamma_i / \beta_i$ is the relative degradation rate for gene $i$.

**Priors for characteristic scales:**
\begin{align}
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \label{eq-U0-prior}
\end{align}

where $U_{0i} = \alpha_i / \beta_i$ is the characteristic concentration scale for gene $i$.

**Priors for effective capture efficiency:**
\begin{align}
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2) \label{eq-lambda-prior}
\end{align}

where $\lambda_j$ represents the **lumped effective capture efficiency** for cell $j$.

**Dimensionless differential equations:**
The system is governed by the dimensionless equations:
\begin{align}
    \frac{du^*}{dt^*} &= 1 - u^* \label{eq-dimless-u-ode}, \\
    \frac{ds^*}{dt^*} &= u^* - \gamma^* s^* \label{eq-dimless-s-ode}
\end{align}

where $t^* = \beta t$, $u^* = u/U_0$, $s^* = s/U_0$, and $\gamma^* = \gamma/\beta$.

**Analytical solutions:**
Given dimensionless initial conditions $u^*_{0i}, s^*_{0i}$ at time $t^*_0 = 0$, we define the helper variable:
\begin{align}
    \xi_i &= \frac{u^*_{0i} - 1}{\gamma^*_i - 1} \label{eq-xi-helper}
\end{align}

The complete solutions are:

\begin{align}
    u^*_{ij} &= 1 + (u^*_{0i} - 1) e^{-t^*_j} \\
    {s^{\ast}}^{k}_{ij} &= 
      \begin{cases}
        \frac{1}{\gamma^{\ast}_i} + 
        \left( s^{\ast}_{0i} - \xi_i - \frac{1}{\gamma^{\ast}_i} \right) \cdot e^{-\gamma^{\ast}_i {t^{\ast}}^k_j} + 
        \xi_i \cdot e^{-{t^{\ast}}^k_j},& \gamma^{\ast}_i \neq 1 \\

        1 + (s^{\ast}_{0i} - 1) e^{-{t^{\ast}}^k_j} + 
          (u^{\ast}_{0i} - 1) {t^{\ast}}^k_j e^{-{t^{\ast}}^k_j},& \gamma^{\ast}_i = 1 \\
      \end{cases}, \label{eq-s-star-model-cell}
\end{align}

**Poisson observation model with characteristic scaling:**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \label{eq-dimless-u-obs-poisson}, \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij}) \label{eq-dimless-s-obs-poisson}
\end{align}

where:

- $i \in \{1, \ldots, G\}$ indexes genes
- $j \in \{1, \ldots, N\}$ indexes cells
- $t^*_j$ are observed dimensionless time coordinates for each cell
- $u^*_{0i}, s^*_{0i}$ are dimensionless initial conditions for each gene
- $u^*_{ij}, s^*_{ij}$ are the latent dimensionless RNA concentrations
- $U_{0i}$ is the characteristic concentration scale for gene $i$
- $\lambda_j$ is the lumped effective capture efficiency for cell $j$

### Parameter Interpretability

The dimensionless approach provides **natural identifiability** and **clear biological interpretation** for all inferred parameters:

#### **Core Dimensionless Parameters (Gene-Specific)**

**$\gamma^*_i$ (Relative degradation rate)**

- **Definition**: $\gamma^*_i = \gamma_i / \beta_i$
- **Interpretation**: How fast mRNA degrades relative to how fast pre-mRNA gets spliced
- **Biological meaning**:
  - $\gamma^*_i < 1$: mRNA is more stable than pre-mRNA processing time
  - $\gamma^*_i = 1$: mRNA degradation matches splicing timescale (special case)
  - $\gamma^*_i > 1$: mRNA degrades faster than splicing occurs
- **Special case**: When $\gamma^*_i = 1$, the analytical solution has a different form with a $t^*_j e^{-t^*_j}$ term
- **Helper variable**: $\xi_i = \frac{u^*_{0i} - 1}{\gamma^*_i - 1}$ (undefined when $\gamma^*_i = 1$)
- **Example**: $\gamma^*_i = 0.5$ means mRNA half-life is twice as long as the characteristic splicing time

#### **Characteristic Scales (Gene-Specific)**

**$U_{0i}$ (Characteristic concentration scale)**

- **Definition**: $U_{0i} = \alpha_i / \beta_i$
- **Units**: molecules/cell
- **Interpretation**: The steady-state pre-mRNA level that would be reached if there were no degradation
- **Biological meaning**: Represents the gene's "expression capacity" - how many molecules it can produce per splicing timescale
- **Example**: $U_{0i} = 100$ molecules/cell means this gene's transcription-splicing balance produces ~100 molecules per characteristic time

#### **Effective Capture Efficiency (Cell-Specific)**

**$\lambda_j$ (Lumped effective capture efficiency)**

- **Definition**: Cell-specific composite technical efficiency
- **Units**: Dimensionless (positive real number)
- **Interpretation**: Overall efficiency of detecting RNA molecules in cell $j$
- **Technical factors lumped together**:
  1. **True capture efficiency**: Fraction of molecules actually captured during library prep
  2. **Library size effects**: Total sequencing depth for this cell
  3. **Batch effects**: Systematic differences between experimental batches
  4. **Cell quality**: Cell viability, membrane integrity, RNA degradation
  5. **Ambient RNA**: Background contamination (modeled as scaling factor)
  6. **Technical dropout**: Stochastic detection failures
- **Example**: $\lambda_j = 0.5$ indicates this cell has 50% of the expected detection efficiency compared to a "reference" cell

#### **Derived Biological Quantities**

From the inferred parameters, you can reconstruct the original dimensional parameters:

**$\alpha_i$ (Transcription rate)**

- **Formula**: $\alpha_i = U_{0i} / T_{0i}$ (where $T_{0i} = 1/\beta_i$ is inferred from time scale)
- **Units**: molecules/(cell·hour)
- **Interpretation**: How many pre-mRNA molecules are transcribed per hour

**$\beta_i$ (Splicing rate)**

- **Formula**: $\beta_i = 1 / T_{0i}$ (from dimensionless time scale)
- **Units**: hour⁻¹
- **Interpretation**: Splicing rate constant

**$\gamma_i$ (Degradation rate)**

- **Formula**: $\gamma_i = \gamma^*_i \cdot \beta_i$
- **Units**: hour⁻¹
- **Interpretation**: mRNA degradation rate constant

### Justification for Parameterization

This parameterization is designed to optimally account for identifiability and known biological/technical considerations:

#### **Natural Identifiability**

- **Dimensionless approach**: Eliminates scaling symmetries inherent in dimensional models
- **No post-estimation rescaling**: Parameters are naturally identifiable during inference
- **Hierarchical priors**: Provide regularization without breaking identifiability

#### **Biological Interpretability**

- **$\gamma^*_i$**: Directly interpretable relative degradation rate
- **$U_{0i}$**: Gene expression capacity with clear biological meaning
- **Dimensionless solutions**: Universal dynamics independent of absolute scales

#### **Technical Factor Management**

- **Strategic lumping**: $\lambda_j$ captures multiple technical effects without overparameterization
- **Computational efficiency**: Fewer parameters than separate modeling of each technical factor
- **Robustness**: Works across different experimental protocols and platforms

#### **Connection to Established Theory**

- **Dimensional analysis**: Follows Buckingham π theorem for parameter reduction
- **RNA velocity theory**: Maintains connection to established dynamical systems approach
- **Single-cell best practices**: Accounts for known technical factors in scRNA-seq data

This approach attempts to balance **biological interpretability**, **statistical identifiability**, and **practical implementation**.

### Parameter Recovery Validation

```{python}
#| label: dimensional-count-validation
#| code-fold: true

# Create the simple deterministic model with validation functionality
# model = create_simple_deterministic_model_with_validation()

# # Configure validation parameters
# validation_config = ParameterRecoveryConfig(
#     num_parameter_sets=5,       # Number of parameter sets to test
#     sample_sizes=[50, 100, 200], # Different sample sizes
#     noise_levels=[0.1, 0.2],    # Different noise levels
#     inference_algorithm="SVI",   # Use SVI for speed
#     num_samples=1000,           # Number of inference samples
#     seed=42,                    # Random seed
# )

# # Run parameter recovery validation using registry-based validation components
# report = model.validate_parameter_recovery(validation_config)

# print(f"Validation completed!")
# print(f"Tested {len(report['parameter_sets'])} parameter sets")
# print(f"Overall parameter recovery success rate: {report['summary']['overall_success_rate']:.2%}")

# # Quick validation for development
# quick_results = model.quick_validation(num_genes=3, num_cells=50, noise_level=0.1)
# print(f"Quick validation success rate: {quick_results['summary']['overall_success_rate']:.2%}")

# # List available validation components
# print(f"Available validation components: {model.list_validation_components()}")
```

## Dimensionless analytical dynamics with latent time {#sec-dimless-latent-time}

This validation study extends the dimensionless approach to include **latent time coordinates** that must be inferred along with other parameters. We implement a hierarchical time structure that maintains biological interpretability while ensuring statistical identifiability.

### Model Description

The model uses the same dimensionless dynamics and observation model as the model described in @sec-dimless-observed-time, but replaces observed time coordinates with **hierarchical latent time coordinates**. This approach borrows strength across cells while allowing individual temporal variation.

### Probabilistic Graphical Model

The probabilistic graphical model now includes hierarchical priors for latent dimensionless time coordinates, with time parameters becoming random variables rather than observed quantities.

```{python}
#| label: fig-latent-time-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with hierarchical latent time coordinates.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters for gene-specific parameters
pgm.add_node("mu_init", r"$\mu_{0}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_init", r"$\sigma_{0}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)

# hyperparameters for hierarchical time structure
pgm.add_node("alpha_T", r"$\alpha_{T}$", 5.5, 6, fixed=True)
pgm.add_node("beta_T", r"$\beta_{T}$", 6, 6, fixed=True)
pgm.add_node("alpha_t_loc", r"$\alpha_{t_{loc}}$", 6.5, 6, fixed=True)
pgm.add_node("beta_t_loc", r"$\beta_{t_{loc}}$", 7, 6, fixed=True)
pgm.add_node("alpha_t_scale", r"$\alpha_{t_{scl}}$", 7.5, 6, fixed=True)
pgm.add_node("beta_t_scale", r"$\beta_{t_{scl}}$", 8, 6, fixed=True)

# hyperparameters for lambda (entering from right edge of cell plate)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 6.5, 3.5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6.5, 2.5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("u_star_0i", r"$u^{\ast}_{0i}$", 1, 5)
pgm.add_node("s_star_0i", r"$s^{\ast}_{0i}$", 2, 5)
pgm.add_node("gamma_star_i", r"$\gamma^{\ast}_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# hierarchical time parameters (moved further left)
pgm.add_node("T_max_star", r"$T_{M}^*$", 5.5, 5)
pgm.add_node("t_loc", r"$t_{loc}$", 6.25, 5)
pgm.add_node("t_scale", r"$t_{scl}$", 7, 5)

# latent time coordinates and cell-specific parameters (moved further left, lambda enters from right)
pgm.add_node("t_star_j", r"$t^{\ast}_j$", 5.5, 4)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 3)

# latent variables for cell-specific outcomes (centered between rows)
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    3.75,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    3.75,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.25,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.25,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}

# gene-specific parameter edges
pgm.add_edge("mu_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("mu_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

# hierarchical time structure edges
pgm.add_edge("alpha_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("alpha_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("beta_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("alpha_t_scale", "t_scale", plot_params=edge_params)
pgm.add_edge("beta_t_scale", "t_scale", plot_params=edge_params)

# time hierarchy edges
pgm.add_edge("T_max_star", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_loc", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_scale", "t_star_j", plot_params=edge_params)

# dynamics edges
pgm.add_edge("u_star_0i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("s_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("u_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.25, 4.5, 4.25],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.5, 1.75, 4.5, 2.75],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model extends the dimensionless approach with **hierarchical latent time coordinates**. The key modification is replacing observed time $t^*_j$ with latent time variables that follow a hierarchical prior structure.

**Priors for dimensionless parameters (unchanged from Study 1):**
\begin{align}
    u^*_{0i}, s^*_{0i} &\sim \text{LogNormal}(\mu_{0}, \sigma_{0}^2) \\
    \gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \\
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \\
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
\end{align}

**Hierarchical priors for latent time coordinates:**
\begin{align}
    T_{M}^* &\sim \text{Gamma}(\alpha_{T}, \beta_{T}) \label{eq-T-M-prior} \\
    t_{loc} &\sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}}) \label{eq-t-loc-prior} \\
    t_{scl} &\sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}}) \label{eq-t-scl-prior} \\
    \tilde{t}_j &\sim \text{Normal}(t_{loc}, t_{scl}^2) \quad \text{for } j \in \{1, \ldots, N\} \label{eq-t-tilde-prior} \\
    t^*_j &= T_{M}^* \times \max(\tilde{t}_j, \epsilon) \quad \text{(clipped transformation)} \label{eq-t-star-transform}
\end{align}

$\tilde{t}_j$ represents the **relative temporal position** of cell $j$ within the population distribution, and $t^*_j$ represents the **actual dimensionless time coordinate**. The clipping operation $\max(\tilde{t}_j, \epsilon)$ with $\epsilon = 10^{-5}$ ensures that all time coordinates remain positive, maintaining biological realism (cells cannot be "before" the process) and mathematical consistency with the analytical solutions. While $\tilde{t}_j$ is not explicitly shown in the PGM for space constraints, the clipped transformation is implicitly included in the $t^*_j$ node.

**Dimensionless analytical solutions (unchanged):**
The same analytical solutions from Study 1 apply, but now using latent $t^*_j$:
\begin{align}
    u^*_{ij} &= 1 + (u^*_{0i} - 1) e^{-t^*_j} \\
    s^*_{ij} &= \begin{cases}
        \frac{1}{\gamma^*_i} + \left(s^*_{0i} - \xi_i - \frac{1}{\gamma^*_i}\right) e^{-\gamma^*_i t^*_j} + \xi_i e^{-t^*_j} & \text{if } \gamma^*_i \neq 1 \\
        1 + (s^*_{0i} - 1) e^{-t^*_j} + (u^*_{0i} - 1) t^*_j e^{-t^*_j} & \text{if } \gamma^*_i = 1
    \end{cases}
\end{align}

where $\xi_i = \frac{u^*_{0i} - 1}{\gamma^*_i - 1}$.

**Observation model (unchanged):**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij})
\end{align}

### Hierarchical Time Parameter Interpretability

The hierarchical time structure introduces new parameters with clear biological and statistical interpretations:

#### **Global Time Scale Parameters**

**$T_{M}^*$ (Global dimensionless time scale)**

- **Definition**: Global scaling factor for dimensionless time coordinates
- **Units**: Dimensionless (in units of characteristic splicing time)
- **Interpretation**: Characteristic temporal extent of the biological process
- **Biological meaning**: Represents the typical time scale over which the biological process unfolds
- **Model role**: Multiplicative scaling factor in $t^*_j \sim T_{M}^* \times \text{Normal}(t_{loc}, t_{scl}^2)$
- **Prior**: $T_{M}^* \sim \text{Gamma}(\alpha_{T}, \beta_{T})$ ensures positive values with flexible tail behavior
- **Example**: $T_{M}^* = 5$ means the process typically spans ~5 characteristic splicing times

#### **Population-Level Time Parameters**

**$t_{loc}$ (Population relative time location)**

- **Definition**: Population-level location parameter for relative time distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: Central tendency of where cells are located in relative time
- **Biological meaning**: Typical relative temporal position of cells in the biological process
- **Prior**: $t_{loc} \sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}})$ ensures positive location with flexible shape
- **Statistical role**: Allows borrowing strength across cells while permitting individual variation
- **Example**: $t_{loc} = 0.7$ means cells are typically positioned at 70% through the relative process timeline

**$t_{scl}$ (Population relative time scale)**

- **Definition**: Population-level scale parameter for relative time distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: How much relative temporal variation exists across cells
- **Biological meaning**: Degree of temporal heterogeneity in the cell population
- **Prior**: $t_{scl} \sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}})$ ensures positive scale with flexible shape
- **Statistical role**: Controls the amount of shrinkage toward the population mean
- **Example**: $t_{scl} = 0.2$ indicates relatively tight temporal clustering around $t_{loc}$

#### **Cell-Specific Time Coordinates**

**$\tilde{t}_j$ (Cell-specific relative time)**

- **Definition**: Latent relative time coordinate for cell $j$ within the population distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: Cell's position relative to the population temporal distribution
- **Biological meaning**: Where this cell sits in the relative temporal progression
- **Prior**: $\tilde{t}_j \sim \text{Normal}(t_{loc}, t_{scl}^2)$ allows natural population variation
- **Range**: Can be negative (before typical process) or greater than 1 (after typical process)
- **Example**: $\tilde{t}_j = -0.2$ means this cell would be before the typical process start; $\tilde{t}_j = 1.3$ means after typical completion

**$t^*_j$ (Cell-specific dimensionless time)**

- **Definition**: Actual dimensionless time coordinate for cell $j$ after clipping
- **Units**: Dimensionless (in units of characteristic splicing time)
- **Interpretation**: How many splicing events have elapsed for this specific cell
- **Biological meaning**: Cell's absolute position along the temporal trajectory of the biological process
- **Transformation**: $t^*_j = T_{M}^* \times \max(\tilde{t}_j, \epsilon)$ with $\epsilon = 10^{-5}$
- **Constraint**: Always positive, ensuring mathematical consistency with analytical solutions
- **Example**: If $T_{M}^* = 5$, $\tilde{t}_j = 0.6$, then $t^*_j = 3.0$ characteristic splicing times; if $\tilde{t}_j = -0.1$, then $t^*_j = 5 \times 10^{-5}$ (clipped)

### Properties of Gamma/Normal Hierarchical Time Structure

#### **Statistical Benefits**

- **Improved identifiability**: Hierarchical structure provides regularization without redundant parameters
- **Borrowing strength**: Information shared across cells improves parameter estimation
- **Uncertainty quantification**: Full posterior distributions for all time parameters
- **Robustness**: Less sensitive to outlier cells or sparse data
- **No truncation constraints**: Avoids computational complexity of truncated distributions
- **Clear parameter roles**: $T_{M}^*$ controls global scale, $t_{loc}$ and $t_{scl}$ control population distribution

#### **Biological Interpretability**

- **Dimensionless time**: Universal interpretation across experimental conditions
- **Population heterogeneity**: Captures natural variation in biological timing
- **Individual trajectories**: Each cell has its own temporal position
- **Flexible temporal range**: $\tilde{t}_j$ can represent cells before or after the typical process timeline
- **Biological realism**: Clipping ensures cells cannot be "before" the process start ($t^*_j \geq \epsilon$)
- **Mathematical consistency**: Positive time coordinates maintain validity of analytical solutions

#### **Computational Efficiency**

- **Standard distributions**: Gamma and Normal distributions are computationally efficient
- **No truncation**: Avoids complex truncated distribution sampling
- **Simple clipping**: $\max(\tilde{t}_j, \epsilon)$ operation is computationally trivial
- **Analytical solutions**: Fast likelihood evaluation for validation
- **Hierarchical sampling**: Efficient MCMC mixing through population-level parameters
- **Deterministic transformation**: $t^*_j = T_{M}^* \times \max(\tilde{t}_j, \epsilon)$ is simple and fast

## Dimensionless Analytical Dynamics with Latent Time and Piecewise Activation {#sec-dimless-latent-piecewise}

This validation study introduces **piecewise constant transcription rates** while maintaining analytical tractability and resolving critical dimensional analysis inconsistencies identified in the piecewise activation framework. The key innovation is a **dimensionally consistent parameterization** that eliminates parameter redundancy by fixing the reference transcription state, while maintaining biological interpretability through fold-change parameters.

### Model Description

The model extends Study 2 by replacing the constant transcription rate $\alpha^* = 1$ with a **piecewise constant transcription function** $\alpha^*_i(t^*)$ that varies over time for each gene. To resolve dimensional analysis violations, we implement a **constrained parameterization** where the off-state transcription rate serves as a fixed reference ($\alpha^*_{\text{off}i} = 1.0$), eliminating parameter redundancy while maintaining biological interpretability through fold-change parameters.

### Dimensionally Consistent Piecewise Framework

#### Reference State Parameterization

To eliminate parameter redundancy identified in the dimensional analysis, we fix the off-state as a reference:

$$\alpha^*_{\text{off}i} = 1.0 \quad \text{(fixed reference, not inferred)}$$

This choice establishes a **consistent dimensional reference** where $U_{0i}$ unambiguously represents the characteristic concentration scale corresponding to the off-state transcription rate.

#### Extended Temporal Framework with Pre-Activation

To accommodate realistic gene expression scenarios, including genes that are already activated when observation begins, we extend the temporal framework to allow **negative onset times**.

#### Piecewise Transcription Rate Function

For each gene $i$, the dimensionless transcription rate follows a three-phase piecewise constant function:

$$\alpha^*_i(t^*) := \begin{cases}
1.0 & \text{if } t^* < t^*_{0,\text{on}i}, \\
R_{\text{on},i} & \text{if } t^*_{0,\text{on}i} \leq t^* < t^*_{0,\text{on}i} + \delta^*_i, \\
1.0 & \text{if } t^* \geq t^*_{0,\text{on}i} + \delta^*_i
\end{cases}$$

where:

- $\alpha^*_{\text{off}i} = 1.0$ is the fixed reference transcription rate
- $R_{\text{on},i} = \alpha^*_{\text{on}i}/\alpha^*_{\text{off}i} = \alpha^*_{\text{on}i}$ is the fold-change during activation (inferred parameter)
- $t^*_{0,\text{on}i}$ is the dimensionless activation onset time (can be negative for pre-activation scenarios)
- $\delta^*_i$ is the dimensionless activation duration

#### Biological Interpretation of Negative Onset Times

When $t^*_{0,\text{on}i} < 0$:

- The gene was **already activated** before observation began ($t^* = 0$)
- Cells at early timepoints may show **high expression** for such genes
- The model captures **pre-existing activation states** in addition to activation events during observation
- **Biological examples**: Early developmental genes already active when profiling begins, stress response genes in cells experiencing ongoing stress, lineage commitment factors in partially committed progenitors

### Steady-State Initial Conditions

Initial conditions are fixed to the off-state steady-state values:

$$u^*_{0i} = 1.0, \quad s^*_{0i} = \frac{1.0}{\gamma^*_i} = \frac{1}{\gamma^*_i}$$

This eliminates the need to infer $u^*_{0i}$ and $s^*_{0i}$ as separate parameters while providing equivalent modeling flexibility through the characteristic scale $U_{0i}$ and fold-change $R_{\text{on},i}$.

### Analytical Solutions for Each Phase

The dimensionless system with piecewise activation becomes:

$$\begin{align}
\frac{du^{\ast}}{dt^{\ast}} &= \alpha^*_i(t^*) - u^{\ast} \\
\frac{ds^{\ast}}{dt^{\ast}} &= u^{\ast} - \gamma^{\ast}_i s^{\ast}
\end{align}$$

We solve this system analytically for each of the three phases:

#### **Phase 1: Off State** ($t^* < t^*_{0,\text{on}i}$)

With constant transcription rate $\alpha^*_{\text{off}i} = 1.0$ and initial conditions at steady state, the system remains at equilibrium:

$$\begin{align}
u^*_{ij}(t^*) &= 1.0 \\
s^*_{ij}(t^*) &= \frac{1.0}{\gamma^*_i}
\end{align}$$

**Note**: This phase may not be observed if $t^*_{0,\text{on}i} < 0$ (pre-activation scenario).

#### **Phase 2: On State** ($t^*_{0,\text{on}i} \leq t^* < t^*_{0,\text{on}i} + \delta^*_i$)

Let $\tau_{\text{on}} = t^* - t^*_{0,\text{on}i}$ be the time since activation onset. The system transitions from the off-state steady state toward the on-state steady state.

**Initial conditions for Phase 2:**
$$u^*_{\text{on},0i} = 1.0, \quad s^*_{\text{on},0i} = \frac{1.0}{\gamma^*_i}$$

**Analytical solutions:**

For $\gamma^*_i \neq 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{on}}) &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\tau_{\text{on}}} \\
s^*_{ij}(\tau_{\text{on}}) &= \frac{R_{\text{on},i}}{\gamma^*_i} + \left(\frac{1.0}{\gamma^*_i} - \xi_{\text{on}i} - \frac{R_{\text{on},i}}{\gamma^*_i}\right) e^{-\gamma^*_i \tau_{\text{on}}} + \xi_{\text{on}i} e^{-\tau_{\text{on}}}
\end{align}$$

where $\xi_{\text{on}i} = \frac{1.0 - R_{\text{on},i}}{\gamma^*_i - 1}$.

For $\gamma^*_i = 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{on}}) &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\tau_{\text{on}}} \\
s^*_{ij}(\tau_{\text{on}}) &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\tau_{\text{on}}} + (1.0 - R_{\text{on},i}) \tau_{\text{on}} e^{-\tau_{\text{on}}}
\end{align}$$

**Special case interpretation ($\gamma^*_i = 1$):**

The case $\gamma^*_i = 1$ represents **balanced splicing-degradation kinetics** where mRNA degradation occurs at exactly the same rate as pre-mRNA splicing. This creates a mathematical resonance that fundamentally changes the system's dynamics:

- **Biological meaning**: The characteristic timescales for splicing ($1/\beta_i$) and degradation ($1/\gamma_i$) are identical
- **Mathematical consequence**: The standard exponential solutions become degenerate, requiring the additional $\tau_{\text{on}} e^{-\tau_{\text{on}}}$ term
- **Physical interpretation**: The $\tau e^{-\tau}$ term represents the accumulation of mRNA over time when production and degradation rates are perfectly balanced
- **Parameter recovery implications**: Inference near $\gamma^*_i = 1$ may exhibit slower convergence due to the discontinuous derivative in the analytical solutions
- **Numerical considerations**: The transition between $\gamma^*_i \neq 1$ and $\gamma^*_i = 1$ solutions requires careful handling to maintain numerical stability

#### **Phase 3: Return to Off State** ($t^* \geq t^*_{0,\text{on}i} + \delta^*_i$)

Let $\tau_{\text{off}} = t^* - (t^*_{0,\text{on}i} + \delta^*_i)$ be the time since returning to the off state. The system transitions from the end-of-phase-2 state back toward the off-state steady state.

**Initial conditions for Phase 3:**

The initial conditions for Phase 3 are the endpoint values from Phase 2, computed explicitly as:

For $\gamma^*_i \neq 1$:
$$\begin{align}
u^*_{\text{off},0i} &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\delta^*_i} \\
s^*_{\text{off},0i} &= \frac{R_{\text{on},i}}{\gamma^*_i} + \left(\frac{1.0}{\gamma^*_i} - \xi_{\text{on}i} - \frac{R_{\text{on},i}}{\gamma^*_i}\right) e^{-\gamma^*_i \delta^*_i} + \xi_{\text{on}i} e^{-\delta^*_i}
\end{align}$$

For $\gamma^*_i = 1$:
$$\begin{align}
u^*_{\text{off},0i} &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\delta^*_i} \\
s^*_{\text{off},0i} &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\delta^*_i} + (1.0 - R_{\text{on},i}) \delta^*_i e^{-\delta^*_i}
\end{align}$$

where $\xi_{\text{on}i} = \frac{1.0 - R_{\text{on},i}}{\gamma^*_i - 1}$ for the $\gamma^*_i \neq 1$ case.

**Analytical solutions:**

For $\gamma^*_i \neq 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{off}}) &= 1.0 + (u^*_{\text{off},0i} - 1.0) e^{-\tau_{\text{off}}} \\
s^*_{ij}(\tau_{\text{off}}) &= \frac{1.0}{\gamma^*_i} + \left(s^*_{\text{off},0i} - \xi_{\text{off}i} - \frac{1.0}{\gamma^*_i}\right) e^{-\gamma^*_i \tau_{\text{off}}} + \xi_{\text{off}i} e^{-\tau_{\text{off}}}
\end{align}$$

where $\xi_{\text{off}i} = \frac{u^*_{\text{off},0i} - 1.0}{\gamma^*_i - 1}$.

For $\gamma^*_i = 1$:
$$\begin{align}
u^*_{ij}(\tau_{\text{off}}) &= 1.0 + (u^*_{\text{off},0i} - 1.0) e^{-\tau_{\text{off}}} \\
s^*_{ij}(\tau_{\text{off}}) &= 1.0 + (s^*_{\text{off},0i} - 1.0) e^{-\tau_{\text{off}}} + (u^*_{\text{off},0i} - 1.0) \tau_{\text{off}} e^{-\tau_{\text{off}}}
\end{align}$$

### Gene Expression Pattern Classification

This piecewise framework enables representation of diverse gene expression patterns through specific parameter combinations. Each pattern is defined by quantitative parameter ranges applied to **relative temporal parameters** that create distinct temporal dynamics when scaled by the global time parameter $T_M^*$.

**Parameter Framework**: The classification uses relative temporal parameters ($\tilde{t}^*_{0,\text{on}i}$, $\tilde{\delta}^*_i$) that are scaled by the global maximum time $T_M^*$ to produce absolute temporal parameters:

$$\begin{align}
t^*_{0,\text{on}i} &= T_M^* \times \tilde{t}^*_{0,\text{on}i} \quad \text{(absolute activation onset time)} \\
\delta^*_i &= T_M^* \times \tilde{\delta}^*_i \quad \text{(absolute activation duration)}
\end{align}$$

This hierarchical structure separates global temporal scaling from gene-specific temporal patterns, enabling consistent pattern classification across different experimental timescales.

#### **Pre-Activation Patterns**

**Characteristics**: Genes that were already activated before observation began, showing decay-only dynamics from an initially activated steady-state.

**Parameter specifications**:

- $\tilde{t}^*_{0,\text{on}i} < 0.0$ (relative activation onset before observation window)
- $R_{\text{on},i} > 2.0$ (moderate to strong fold-change during activation)

**Biological interpretation**: These genes underwent activation before the experimental observation window. During the observed period, they exhibit decay-only dynamics as they return toward baseline expression levels. The negative relative onset time indicates that activation occurred in the "past" relative to the observation start.

**Biological examples**: Early developmental genes, maternal transcripts during development, lineage commitment factors established before observation, stress response genes in ongoing stress conditions

#### **Transient Activation Patterns**

**Characteristics**: Genes that show complete activation-decay cycles within the observation window, exhibiting brief, pulse-like activation followed by return toward baseline.

**Parameter specifications**:

- $\tilde{t}^*_{0,\text{on}i} > 0.0$ (relative activation within observation window)
- $\tilde{t}^*_{0,\text{on}i} < 0.5$ (activation early enough to complete cycle within 50% of timeline)
- $\tilde{\delta}^*_i < 0.4$ (short activation duration, 40% of timeline or less)
- $R_{\text{on},i} > 2.0$ (sufficient fold-change to observe activation)

**Biological interpretation**: These genes activate early enough and for a short enough duration that the complete activation-decay cycle is observable within the experimental window. The constraints ensure that both the activation and subsequent decay phases are captured.

**Biological examples**: Immediate early genes, signaling molecules, transient developmental regulators, cell cycle checkpoint genes, acute stress response genes

#### **Sustained Activation Patterns**

**Characteristics**: Genes that become activated early and remain highly expressed throughout most of the observation period, showing net increase over the observation window.

**Parameter specifications**:

- $\tilde{t}^*_{0,\text{on}i} > 0.0$ (relative activation within observation window)
- $\tilde{t}^*_{0,\text{on}i} < 0.3$ (early activation onset within 30% of timeline)
- $\tilde{\delta}^*_i > 0.5$ (long activation duration, more than 50% of timeline)
- $R_{\text{on},i} > 2.0$ (strong fold-change during activation)

**Biological interpretation**: These genes activate early in the observation window and maintain high expression levels throughout most of the observed period. The long activation duration relative to the observation window means that decay back to baseline is either minimal or occurs beyond the observation period.

**Biological examples**: Lineage-specific transcription factors, structural proteins, metabolic enzymes, terminal differentiation markers, long-term stress adaptation genes

### Mathematical Framework for Pre-Activation Scenarios

The Normal prior for onset times enables modeling of **pre-activation scenarios** where genes are already activated when observation begins. This extension is mathematically valid and biologically realistic:

#### **Mathematical Validity of Negative Onset Times**

When $t^*_{0,\text{on}i} < 0$:

1. **Phase determination remains consistent**: For any observed time $t^* \geq 0$, we can still determine which phase applies by comparing $t^*$ to $t^*_{0,\text{on}i}$ and $t^*_{0,\text{on}i} + \delta^*_i$

2. **Analytical solutions remain valid**: All exponential solutions are well-defined for negative onset times

3. **Biological interpretation is clear**: Negative onset simply means activation occurred before the observation window

#### **Implementation Considerations**

- **Phase 1 may be unobserved**: If $t^*_{0,\text{on}i} < 0$, no observed cells will be in Phase 1
- **Phase 2 starts immediately**: Cells at $t^* = 0$ may already be in the activated state
- **Duration constraints**: For pre-activation genes, $\delta^*_i > |t^*_{0,\text{on}i}|$ ensures activation extends into the observation window

### Constraint Feasibility Analysis and Optimization

The pattern constraints above were optimized using a systematic CDF-based analysis to ensure mathematical feasibility while preserving biological interpretability. The analysis now includes both LogNormal and Normal distributions to handle the extended temporal framework.

#### **Mathematical Framework for Constraint Analysis**

For each pattern constraint, we calculate the probability that a parameter sampled from its prior distribution satisfies the constraint using cumulative distribution functions (CDFs).

For **LogNormal parameters** ($R_{\text{on},i}$, $\delta^*_i$), the probability of satisfying constraint $X > \theta$ is:

$$P(X > \theta) = 1 - \Phi\left(\frac{\log(\theta) - \mu}{\sigma}\right)$$

For **Normal parameters** ($t^*_{0,\text{on}i}$), the probability of satisfying constraint $X > \theta$ is:

$$P(X > \theta) = 1 - \Phi\left(\frac{\theta - \mu}{\sigma}\right)$$

where $\Phi$ is the standard normal CDF. The joint probability of satisfying all constraints for a pattern is the product of individual constraint probabilities (assuming independence).

#### **Constraint Feasibility Assessment**

```{python}
#| code-fold: true
#| code-summary: "Show/Hide Code"
#| eval: false

# CDF-based feasibility analysis for pattern constraints
from scipy import stats
import numpy as np

def calculate_lognormal_cdf_probability(loc, scale, threshold, upper=True):
    """Calculate P(X > threshold) or P(X < threshold) for LogNormal(loc, scale)."""
    if upper:
        return 1 - stats.lognorm.cdf(threshold, s=scale, scale=np.exp(loc))
    else:
        return stats.lognorm.cdf(threshold, s=scale, scale=np.exp(loc))

def calculate_normal_cdf_probability(loc, scale, threshold, upper=True):
    """Calculate P(X > threshold) or P(X < threshold) for Normal(loc, scale)."""
    if upper:
        return 1 - stats.norm.cdf(threshold, loc=loc, scale=scale)
    else:
        return stats.norm.cdf(threshold, loc=loc, scale=scale)

# Prior hyperparameters (updated for relative temporal parameterization)
priors = {
    'R_on': {'loc': 0.916, 'scale': 0.4},              # log(2.5), fold-change (LogNormal)
    'tilde_t_on_star': {'loc': 0.5, 'scale': 0.8},     # Normal(0.5, 0.8²), relative onset (allows negatives)
    'tilde_delta_star': {'loc': -0.8, 'scale': 0.45},  # log(0.45), relative duration (LogNormal)
}

# Calculate constraint feasibility for each pattern (updated to match script implementation)
patterns = {
    'pre_activation': [
        ('tilde_t_on_star', '<', 0.0),  # Activation before observation window
        ('R_on', '>', 2.0),             # Moderate to strong fold change
    ],
    'transient': [
        ('tilde_t_on_star', '>', 0.0),  # Activation within observation window
        ('tilde_t_on_star', '<', 0.5),  # Early enough to complete cycle (50% of timeline)
        ('tilde_delta_star', '<', 0.4), # Short pulse duration (40% of timeline)
        ('R_on', '>', 2.0),             # Sufficient fold change to observe
    ],
    'sustained': [
        ('tilde_t_on_star', '>', 0.0),  # Activation within observation window
        ('tilde_t_on_star', '<', 0.3),  # Early activation onset (30% of timeline)
        ('tilde_delta_star', '>', 0.5), # Long activation duration (50% of timeline)
        ('R_on', '>', 2.0),             # Strong fold change
    ]
}

for pattern_name, constraints in patterns.items():
    joint_prob = 1.0
    print(f"\n{pattern_name.upper()} PATTERN:")

    for param, op, threshold in constraints:
        prior = priors[param]

        if param == 'tilde_t_on_star':  # Normal distribution
            prob = calculate_normal_cdf_probability(
                prior['loc'], prior['scale'], threshold, upper=(op == '>')
            )
        else:  # LogNormal distribution
            prob = calculate_lognormal_cdf_probability(
                prior['loc'], prior['scale'], threshold, upper=(op == '>')
            )

        joint_prob *= prob
        print(f"  P({param} {op} {threshold}) = {prob:.3f}")

    print(f"  Joint probability: {joint_prob:.3f}")
```

### Probabilistic Graphical Model

The probabilistic graphical model extends Study 2 by adding gene-specific piecewise activation parameters while maintaining the hierarchical latent time structure. For visual clarity, we use $\theta_i$ to represent the vector of non-temporal piecewise activation parameters $(\gamma^*_i, R_{\text{on},i})$ and $\Delta_i$ to represent the vector of relative temporal gene parameters $(\tilde{t}^*_{0,\text{on}i}, \tilde{\delta}^*_i)$. Note that $\alpha^*_{\text{off}i} = 1.0$ is fixed and not shown as a random variable.

```{python}
#| label: fig-piecewise-activation-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with hierarchical latent time coordinates and piecewise activation.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters for gene-specific parameters
pgm.add_node("mu_theta", r"$\mu_{\theta}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_theta", r"$\sigma_{\theta}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_Delta", r"$\mu_{\Delta}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_Delta", r"$\sigma_{\Delta}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)

# hyperparameters for hierarchical time structure
pgm.add_node("alpha_T", r"$\alpha_{T}$", 5.5, 6, fixed=True)
pgm.add_node("beta_T", r"$\beta_{T}$", 6, 6, fixed=True)
pgm.add_node("alpha_t_loc", r"$\alpha_{t_{loc}}$", 6.5, 6, fixed=True)
pgm.add_node("beta_t_loc", r"$\beta_{t_{loc}}$", 7, 6, fixed=True)
pgm.add_node("alpha_t_scale", r"$\alpha_{t_{scl}}$", 7.5, 6, fixed=True)
pgm.add_node("beta_t_scale", r"$\beta_{t_{scl}}$", 8, 6, fixed=True)

# hyperparameters for lambda (entering from right edge of cell plate)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 6.5, 3.5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6.5, 2.5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("theta_i", r"$\theta_i$", 1, 5)
pgm.add_node("Delta_i", r"$\Delta_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# hierarchical time parameters (moved further left)
pgm.add_node("T_max_star", r"$T_{M}^*$", 5.5, 5)
pgm.add_node("t_loc", r"$t_{loc}$", 6.25, 5)
pgm.add_node("t_scale", r"$t_{scl}$", 7, 5)

# latent time coordinates and cell-specific parameters (moved further left, lambda enters from right)
pgm.add_node("t_star_j", r"$t^{\ast}_j$", 5.5, 4)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 3)

# latent variables for cell-specific outcomes (centered between rows)
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    3.75,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    3.75,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.25,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.25,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}

# gene-specific parameter edges
pgm.add_edge("mu_theta", "theta_i", plot_params=edge_params)
pgm.add_edge("sigma_theta", "theta_i", plot_params=edge_params)
pgm.add_edge("mu_Delta", "Delta_i", plot_params=edge_params)
pgm.add_edge("sigma_Delta", "Delta_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

# hierarchical time structure edges
pgm.add_edge("alpha_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("alpha_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("beta_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("alpha_t_scale", "t_scale", plot_params=edge_params)
pgm.add_edge("beta_t_scale", "t_scale", plot_params=edge_params)

# time hierarchy edges
pgm.add_edge("T_max_star", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_loc", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_scale", "t_star_j", plot_params=edge_params)
# temporal scaling edge for gene parameters
pgm.add_edge("T_max_star", "Delta_i", plot_params=edge_params)

# dynamics edges
pgm.add_edge("theta_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("theta_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("Delta_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("Delta_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.25, 4.5, 4.25],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.5, 1.75, 4.5, 2.75],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model combines the hierarchical latent time structure from Study 2 with piecewise constant transcription rates and steady-state initial conditions to resolve identifiability while enabling rich gene expression dynamics.

**Notation mapping between PGM and mathematical description:**

In the PGM above, we use simplified notation for visual clarity:

- $\theta_i$ represents the vector of **non-temporal** piecewise activation parameters $(\gamma^*_i, R_{\text{on},i})$
- $\Delta_i$ represents the vector of **relative temporal** gene parameters $(\tilde{t}^*_{0,\text{on}i}, \tilde{\delta}^*_i)$
- The hyperparameters $\mu_{\theta}, \sigma_{\theta}^2$ represent the collection of hyperparameters for all components of $\theta_i$
- The hyperparameters $\mu_{\Delta}, \sigma_{\Delta}^2$ represent the collection of hyperparameters for all components of $\Delta_i$
- The absolute timing parameters $t^*_{0,\text{on}i} = T_{M}^* \times \tilde{t}^*_{0,\text{on}i}$ and $\delta^*_i = T_{M}^* \times \tilde{\delta}^*_i$ are computed deterministically
- $\alpha^*_{\text{off}i} = 1.0$ is fixed and not shown as a random variable
- $T_{M}^* \rightarrow \Delta_i$ represents the scaling relationship for all temporal parameters

**Detailed priors for constrained piecewise activation parameters:**

The priors are designed to encode biologically reasonable parameter ranges while eliminating dimensional redundancy and cleanly separating temporal from non-temporal parameters:

**Non-temporal gene-specific parameters:**
\begin{align}
    \gamma^*_i &\sim \text{LogNormal}(\log(1.0), 0.5^2) \quad \text{(relative degradation rate)} \\
    R_{\text{on},i} &\sim \text{LogNormal}(\log(2.5), 0.4^2) \quad \text{(activation fold-change)}
\end{align}

**Relative temporal gene-specific parameters:**
\begin{align}
    \tilde{t}^*_{0,\text{on}i} &\sim \text{Normal}(0.5, 0.8^2) \quad \text{(relative activation onset time, allows negatives)} \\
    \tilde{\delta}^*_i &\sim \text{LogNormal}(\log(0.45), 0.45^2) \quad \text{(relative activation duration)}
\end{align}

**Absolute temporal parameters (deterministic transformations):**
\begin{align}
    t^*_{0,\text{on}i} &= T_{M}^* \times \tilde{t}^*_{0,\text{on}i} \quad \text{(absolute activation onset time)} \\
    \delta^*_i &= T_{M}^* \times \tilde{\delta}^*_i \quad \text{(absolute activation duration)}
\end{align}

**Pattern classification framework**: The three expression patterns are defined by constraints on the relative temporal parameters:

- **Pre-activation**: $\tilde{t}^*_{0,\text{on}i} < 0.0$ and $R_{\text{on},i} > 2.0$
- **Transient**: $0.0 < \tilde{t}^*_{0,\text{on}i} < 0.5$, $\tilde{\delta}^*_i < 0.4$, and $R_{\text{on},i} > 2.0$
- **Sustained**: $0.0 < \tilde{t}^*_{0,\text{on}i} < 0.3$, $\tilde{\delta}^*_i > 0.5$, and $R_{\text{on},i} > 2.0$

**Biological interpretation of prior choices:**

**Non-temporal parameters:**

- **$\gamma^*_i \sim \text{LogNormal}(\log(1.0), 0.5^2)$**: Centers relative degradation around 1 (balanced splicing/degradation), with 95% of values between ~0.37 and ~2.7.

- **$R_{\text{on},i} \sim \text{LogNormal}(\log(2.5), 0.4^2)$**: Centers fold-change at 2.5× during activation, with 95% between ~1.5 and ~4.2.

**Relative temporal parameters:**

- **$\tilde{t}^*_{0,\text{on}i} \sim \text{Normal}(0.5, 0.8^2)$**: Centers relative activation onset at 50% through the process timeline, with 95% between approximately -1.1 and +2.1. **Negative values** enable pre-activation scenarios where genes were already activated before observation began.

- **$\tilde{\delta}^*_i \sim \text{LogNormal}(\log(0.45), 0.45^2)$**: Centers relative activation duration at 45% of the process timeline, with 95% between ~0.18 and ~1.13. This enables both transient (short duration) and sustained (long duration) activation patterns.

**Pattern classification implications:**

- **Pre-activation** ($\tilde{t}^*_{0,\text{on}i} < 0$): ~26.6% probability under the prior
- **Transient** ($0 < \tilde{t}^*_{0,\text{on}i} < 0.5$ and $\tilde{\delta}^*_i < 0.4$): Balanced probability for observable complete cycles
- **Sustained** ($0 < \tilde{t}^*_{0,\text{on}i} < 0.3$ and $\tilde{\delta}^*_i > 0.5$): Balanced probability for long-duration activation

**Temporal scaling transformation:**

- **Absolute onset**: $t^*_{0,\text{on}i} = T_{M}^* \times \tilde{t}^*_{0,\text{on}i}$ scales relative onset to absolute time
- **Absolute duration**: $\delta^*_i = T_{M}^* \times \tilde{\delta}^*_i$ scales relative duration to absolute time
- **Dimensional consistency**: All temporal comparisons now use consistently scaled absolute times

**Parameter interpretation benefits:**

- **Separation of concerns**: Non-temporal kinetics ($\theta_i$) vs temporal patterns ($\Delta_i$)
- **Scale invariance**: Relative temporal patterns are independent of absolute time scale
- **Biological realism**: Global time scale $T_{M}^*$ sets the pace for the entire process

**Priors for other gene-specific parameters (unchanged from Study 2):**
\begin{align}
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2)
\end{align}

**Hierarchical priors for latent time coordinates (unchanged from Study 2):**
\begin{align}
    T_{M}^* &\sim \text{Gamma}(\alpha_{T}, \beta_{T}) \\
    t_{loc} &\sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}}) \\
    t_{scl} &\sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}}) \\
    \tilde{t}_j &\sim \text{Normal}(t_{loc}, t_{scl}^2) \quad \text{for } j \in \{1, \ldots, N\} \\
    t^*_j &= T_{M}^* \times \max(\tilde{t}_j, \epsilon) \quad \text{(clipped transformation)}
\end{align}

**Cell-specific capture efficiency (unchanged from Study 2):**
\begin{align}
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
\end{align}

**Dimensionless dynamics with piecewise activation:**

The dimensionless concentrations are computed using the analytical solutions for each phase as derived above, with the appropriate phase determined by comparing $t^*_j$ to the gene-specific activation parameters $t^*_{0,\text{on}i}$ and $\delta^*_i$.

**Observation model (unchanged):**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij})
\end{align}

### Properties of the Piecewise Framework

#### **Resolved Dimensional Analysis Issues**

- **Eliminates parameter redundancy**: No ambiguity between $U_{0i}$ and $\alpha^*_{\text{off}i}$ since $\alpha^*_{\text{off}i} = 1.0$ (fixed)
- **Clear dimensional structure**: $U_{0i}$ unambiguously represents off-state concentration scale
- **Proper parameter hierarchy**: Each inferred parameter has a unique biological role
- **No separate inference of initial conditions**: $u^*_{0i}, s^*_{0i}$ fixed to steady-state values
- **Biological realism**: Steady-state initial conditions are more plausible than arbitrary values

#### **Enhanced Temporal Modeling**

- **Pre-activation scenarios**: Models genes already activated when observation begins
- **Flexible onset timing**: Normal prior allows negative onset times naturally
- **Biological realism**: Captures realistic experimental scenarios better
- **Maintains population structure**: Hierarchical time modeling preserved

#### **Rich Expression Pattern Representation**

The framework captures three core expression patterns that encompass the full range of biologically relevant temporal dynamics:

- **Pre-activation genes**: Already activated before observation, showing decay-only dynamics from activated steady-state
- **Transient genes**: Complete activation-decay cycles within observation window, exhibiting pulse-like dynamics
- **Sustained genes**: Early activation with long duration, showing net increase over observation period

**Pattern coverage**: These three patterns effectively capture the essential temporal dynamics while eliminating redundant classifications. The relative temporal parameterization ensures consistent pattern identification across different experimental timescales.

#### **Analytical Tractability**

- **Fast likelihood evaluation**: All phases solved analytically
- **Efficient parameter recovery validation**: No numerical integration required
- **Clear mathematical structure**: Each phase has explicit closed-form solution

#### **Biological Interpretability**

- **Dimensionless parameters**: Universal interpretation across experimental conditions
- **Temporal coordination**: Hierarchical time structure captures population-level timing
- **Gene-specific dynamics**: Each gene can follow distinct activation pattern

### Parameter Recovery Validation Strategy

This study will validate the constrained model's ability to:

1. **Recover constrained piecewise parameters**: $\gamma^*_i$, $R_{\text{on},i}$, $\tilde{t}^*_{0,\text{on}i}$, $\tilde{\delta}^*_i$
2. **Handle pre-activation scenarios**: Correctly infer negative relative onset times and their biological implications
3. **Distinguish expression patterns**: Classify genes across the three core patterns (pre-activation, transient, sustained)
4. **Maintain hierarchical time inference**: Recover population-level temporal parameters ($T_M^*$, $t_{loc}$, $t_{scl}$)
5. **Handle realistic noise levels**: Maintain accuracy with Poisson observation noise
6. **Scale efficiently**: Demonstrate computational advantages of reduced parameter space
7. **Validate fold-change interpretation**: Ensure $R_{\text{on},i}$ estimates match true activation strength
8. **Assess dimensional consistency**: Verify elimination of parameter redundancy through fixed $\alpha^*_{\text{off}i} = 1.0$
9. **Validate temporal parameter scaling**: Ensure $T_{M}^*$ scaling correctly propagates from relative to absolute timing parameters
10. **Assess parameter separation**: Verify clean separation between kinetic ($\gamma^*_i$, $R_{\text{on},i}$) and temporal ($\tilde{t}^*_{0,\text{on}i}$, $\tilde{\delta}^*_i$) parameter inference
11. **Validate relative parameter framework**: Confirm that relative temporal parameters enable consistent pattern classification across different experimental timescales
12. **Assess pattern coverage**: Verify that the three-pattern framework adequately captures the diversity of gene expression dynamics in real biological systems

### Parameter Recovery Validation Implementation

The following example demonstrates the user-facing API for performing parameter recovery validation with the piecewise activation model:

```{python}
#| label: piecewise-activation-validation
#| code-fold: true
#| code-summary: "Show/Hide Code"
#| eval: false

# Create the piecewise activation model
model = create_piecewise_activation_model()

print(f"Created piecewise activation model: {model}")
print(f"Model components:")
print(f"  Dynamics: {model.dynamics_model}")
print(f"  Prior: {model.prior_model}")
print(f"  Likelihood: {model.likelihood_model}")
print(f"  Guide: {model.guide_model}")

# Generate prior predictive data with known true parameters
print(f"\nGenerating prior predictive data for validation...")
prior_predictive_adata = model.generate_predictive_samples(
    num_cells=200,
    num_genes=100,
    num_samples=1,
    return_format="anndata"
)

print(f"Prior predictive data generated:")
print(f"  Cells: {prior_predictive_adata.n_obs}")
print(f"  Genes: {prior_predictive_adata.n_vars}")
print(f"  Layers: {list(prior_predictive_adata.layers.keys())}")

# Extract true parameters for validation
true_parameters = prior_predictive_adata.uns.get('true_parameters', {})
print(f"\nTrue parameters available for validation:")
for key in sorted(true_parameters.keys()):
    if key.startswith(('R_on', 'tilde_t_on', 'tilde_delta', 't_on', 'delta', 'gamma_star', 'T_M_star')):
        param_value = true_parameters[key]
        if hasattr(param_value, 'shape') and param_value.size > 1:
            print(f"  {key}: shape {param_value.shape}, range [{param_value.min():.3f}, {param_value.max():.3f}]")
        else:
            print(f"  {key}: {param_value:.3f}")

# Analyze pattern distribution in generated data
print(f"\nPattern analysis of generated genes:")
if 'tilde_t_on_star' in true_parameters and 'tilde_delta_star' in true_parameters:
    tilde_t_on = true_parameters['tilde_t_on_star']
    tilde_delta = true_parameters['tilde_delta_star']
    R_on = true_parameters['R_on']

    # Count genes in each pattern
    pre_activation = (tilde_t_on < 0.0) & (R_on > 2.0)
    transient = (tilde_t_on > 0.0) & (tilde_t_on < 0.5) & (tilde_delta < 0.4) & (R_on > 2.0)
    sustained = (tilde_t_on > 0.0) & (tilde_t_on < 0.3) & (tilde_delta > 0.5) & (R_on > 2.0)

    print(f"  Pre-activation: {pre_activation.sum()} genes ({pre_activation.mean()*100:.1f}%)")
    print(f"  Transient: {transient.sum()} genes ({transient.mean()*100:.1f}%)")
    print(f"  Sustained: {sustained.sum()} genes ({sustained.mean()*100:.1f}%)")
    print(f"  Other patterns: {(~(pre_activation | transient | sustained)).sum()} genes")

# Train model on prior predictive data (parameter recovery)
print(f"\nTraining model for parameter recovery...")
trained_model = model.train(
    adata=prior_predictive_adata,
    max_epochs=1000,  # Reduced for demonstration
    learning_rate=0.01,
    early_stopping=True,
    early_stopping_patience=10,
    use_gpu="auto",
    seed=42
)

# Generate posterior samples from trained model
print(f"\nGenerating posterior samples...")
posterior_samples = trained_model.generate_posterior_samples(
    adata=prior_predictive_adata,
    num_samples=30,
    seed=42,
    return_tensors=True
)

print(f"Posterior samples generated:")
for key in sorted(posterior_samples.keys()):
    if key.startswith(('R_on', 'tilde_t_on', 'tilde_delta', 't_on', 'delta', 'gamma_star', 'T_M_star')):
        param_shape = posterior_samples[key].shape if hasattr(posterior_samples[key], 'shape') else len(posterior_samples[key])
        print(f"  {key}: {param_shape}")

print(f"\nParameter recovery validation completed!")
print(f"This demonstrates the complete workflow from:")
print(f"  1. Model creation with create_piecewise_activation_model()")
print(f"  2. Prior predictive data generation with known parameters")
print(f"  3. Model training on synthetic data")
print(f"  4. Posterior sampling for parameter recovery assessment")
print(f"  5. Comparison of true vs recovered parameters")
print(f"  6. Pattern classification analysis with 3-pattern framework")
```

This validation workflow demonstrates the key capabilities of the piecewise activation model:

- **Analytical tractability**: Fast likelihood evaluation enables efficient parameter recovery validation
- **Rich parameter space**: Includes fold-change parameters, relative temporal parameters, and hierarchical time structure
- **Pre-activation modeling**: Supports negative onset times for genes already activated before observation
- **Dimensional consistency**: Eliminates parameter redundancy through fixed reference state parameterization
- **Biological interpretability**: All parameters have clear biological meaning and interpretable ranges
- **Coarse-grained expression pattern classification**: Classification of temporal expression patterns covering pre-activation, transient, and sustained that should all be able to be generated by the prior and prior predictive in order to ensure the ability to represent the expected collection of expression patterns in the underlying data
- **Relative temporal parameterization**: Enables interpretable parameter values and consistent pattern classification across different experimental timescales and even distinct data sets

The complete validation scripts referenced in the introduction (`prior-predictive-check.py` and `posterior-predictive-check.py`) provide comprehensive parameter recovery validation including visualization and statistical assessment of recovery performance.
