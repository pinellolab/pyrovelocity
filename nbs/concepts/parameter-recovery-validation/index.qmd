---
title: Parameter Recovery Validation
toc: true
number-sections: true
highlight-style: gruvbox
csl: ../../bibstyle.csl
lightbox: auto
format:
  html:
    html-math-method: mathjax
    include-in-header: ../../mathjax.html
format-links: [ipynb]
execute:
  freeze: true
  eval: true
  warning: false
  error: false
  cache: true
author:
  - name: Pyrovelocity Team
    email: team@pyrovelocity.net
abstract: |
  This notebook demonstrates parameter recovery validation for PyroVelocity models using dimensionless models.
  We progress from analytically tractable models where the temporal coordinate is an observed variable toward the more complicated situation of models with latent variables that represent temporal ordering and must therefore be inferred.
  We focus on constructing models that naturally avoid identifiability issues while maintaining biological interpretability,
  using hierarchical priors on characteristic scales and simple accounting of technical artifacts through effective parameters that aggregate sources of error.
  We illustrate how to systematically validate that probabilistic models can recover
  known parameters from synthetic data, which is essential before applying models
  to real-world data where true parameter values are unknown.
keywords: [single-cell transcriptomics, probabilistic modeling, model calibration, model validation, RNA velocity]
bibliography: ../../references.bib
jupyter:
  jupytext:
    cell_metadata_filter: all
    cell_metadata_json: true
    notebook_metadata_filter: all
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: 1.0
      jupytext_version: 1.16.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
  language_info:
    name: python
  rise:
    scroll: true
    theme: black
  toc-autonumbering: true
  toc-showcode: false
  toc-showmarkdowntxt: false
---

## Introduction

Parameter recovery validation is a critical step in validating probabilistic models before applying them to real data. This process involves:

1. **Generating synthetic data** using known parameter values
2. **Running inference** to recover parameters from the synthetic data
3. **Evaluating recovery performance**
4. **Assessing model identifiability**

This notebook demonstrates parameter recovery validation for PyroVelocity models using the dimensionless parameterization that naturally avoids identifiability issues while maintaining biological interpretability. We implement hierarchical priors on characteristic scales and lumped effective capture efficiency, progressing from analytical solutions with observed time to numerical simulation with latent time coordinates. For each model we include a graphical representation of the model's generative process as well as a mathematical description of the prior, observation model, and likelihood. We illustrate how to perform a somewhat simplified version of prior and posterior predictive checking for the piecewise activation model with latent time.

## Model Development

We work through a progression of **dimensionless models** that naturally avoid or aim to avoid identifiability issues while maintaining biological interpretability. Each model builds complexity while preserving the core dimensionless parameterization.

### Dimensionless Analytical Dynamics with Observed Time

This model uses the direct dimensionless approach with analytical solutions:

- **Time coordinates**: Observed dimensionless time $t^*_j$
- **Dynamics**: Analytical dimensionless transcription-splicing-degradation solutions
- **Parameters**: $\gamma^*_i$ (relative degradation), $U_{0i}$ (characteristic scale), $\lambda_j$ (lumped capture efficiency)
- **Prior**: Log-normal hierarchical priors for all parameters
- **Observation Model**: Poisson counts scaled by characteristic scales and capture efficiency
- **Likelihood**: Poisson product distribution
- **Identifiability**: Naturally identifiable through dimensionless parameterization

### Dimensionless Analytical Dynamics with Latent Time

This model introduces latent dimensionless time coordinates:

- **Time coordinates**: Latent $t^*_j$ with hierarchical Gamma/Normal priors
- **Dynamics**: Same dimensionless analytical solutions
- **Parameters**: $\gamma^*_i$, $U_{0i}$, $\lambda_j$, plus hierarchical time structure ($T_{M}^*$, $t_{loc}$, $t_{scl}$)
- **Prior**: Gamma priors for time scales, Normal for relative positions
- **Observation Model**: Same Poisson scaling approach
- **Likelihood**: Poisson

### Dimensionless Analytical Dynamics with Latent Time and Piecewise Activation

This model extends the latent time framework with piecewise constant transcription rates:

- **Time coordinates**: Same hierarchical latent $t^*_j$ structure as previous model
- **Dynamics**: Piecewise constant transcription with three phases (off, on, return-to-off)
- **Parameters**: $\gamma^*_i$, $R_{\text{on},i}$ (fold-change), $t^*_{0,\text{on}i}$ (onset), $\delta^*_i$ (duration), plus hierarchical time structure
- **Key innovation**: Fixed reference state ($\alpha^*_{\text{off}i} = 1.0$) eliminates parameter redundancy
- **Enhanced patterns**: Supports pre-activation scenarios with negative onset times
- **Analytical solutions**: Closed-form solutions for all three phases, including $\gamma^*_i = 1$ special case
- **Biological realism**: Steady-state initial conditions and rich expression pattern representation
- **Observation Model**: Same Poisson scaling with characteristic scales and capture efficiency
- **Likelihood**: Poisson

## Dimensionless analytical dynamics with observed time {#sec-dimless-observed-time}

This validation study focuses on the **direct dimensionless approach** that naturally avoids identifiability issues while maintaining biological interpretability. We follow the theoretical foundation from our [Probabilistic inference in dynamical systems](../inferenceindynamicalsystems/index.qmd) concept guide, implementing hierarchical priors on characteristic scales and lumped effective capture efficiency.

### Model Description

We model the transcription-splicing-degradation system using the **direct dimensionless approach** that naturally avoids identifiability issues while maintaining biological interpretability. This approach fits the dimensionless model directly with hierarchical priors on characteristic scales, eliminating the need for post-estimation rescaling procedures.

The model generates count data for unspliced ($u$) and spliced ($s$) RNA molecules per cell, with dynamics governed by the dimensionless analytical solutions and observation model that scales back to dimensional counts through characteristic scales and effective capture efficiency.

### Probabilistic Graphical Model

The probabilistic graphical model represents the dimensionless transcription-splicing-degradation system with hierarchical priors on characteristic scales and lumped effective capture efficiency. The model directly fits dimensionless parameters while maintaining biological interpretability through characteristic scales.

```{python}
#| label: fig-count-model-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for the dimensionless transcription-splicing-degradation model with hierarchical priors on characteristic scales and lumped effective capture efficiency.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters
pgm.add_node("mu_init", r"$\mu_{0}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_init", r"$\sigma_{0}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 5.5, 5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6, 5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("u_star_0i", r"$u^{\ast}_{0i}$", 1, 5)
pgm.add_node("s_star_0i", r"$s^{\ast}_{0i}$", 2, 5)
pgm.add_node("gamma_star_i", r"$\gamma^{\ast}_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# cell-specific parameters (moved inside cell plate)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 4)

# latent variables for cell-specific outcomes
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    4,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    4,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "t_star_j",
    r"$t^{\ast}_j$",
    5.5,
    3.0,
    observed=True,
    shape="rectangle",
)
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.5,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.5,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}
pgm.add_edge("mu_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("mu_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

pgm.add_edge("u_star_0i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("s_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("u_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)

pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.4, 4.5, 4.2],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.0, 1.9, 5.0, 2.6],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model is defined by the following hierarchical structure using the **direct dimensionless approach**:

**Priors for dimensionless initial conditions:**
\begin{align}
    u^*_{0i}, s^*_{0i} &\sim \text{LogNormal}(\mu_{0}, \sigma_{0}^2) \label{eq-dimless-init-conds-priors}
\end{align}

**Priors for dimensionless kinetic parameters:**
\begin{align}
    \gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \label{eq-gamma-star-prior}
\end{align}

where $\gamma^*_i = \gamma_i / \beta_i$ is the relative degradation rate for gene $i$.

**Priors for characteristic scales:**
\begin{align}
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \label{eq-U0-prior}
\end{align}

where $U_{0i} = \alpha_i / \beta_i$ is the characteristic concentration scale for gene $i$.

**Priors for effective capture efficiency:**
\begin{align}
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2) \label{eq-lambda-prior}
\end{align}

where $\lambda_j$ represents the **lumped effective capture efficiency** for cell $j$.

**Dimensionless differential equations:**
The system is governed by the dimensionless equations:
\begin{align}
    \frac{du^*}{dt^*} &= 1 - u^* \label{eq-dimless-u-ode}, \\
    \frac{ds^*}{dt^*} &= u^* - \gamma^* s^* \label{eq-dimless-s-ode}
\end{align}

where $t^* = \beta t$, $u^* = u/U_0$, $s^* = s/U_0$, and $\gamma^* = \gamma/\beta$.

**Analytical solutions:**
Given dimensionless initial conditions $u^*_{0i}, s^*_{0i}$ at time $t^*_0 = 0$, we define the helper variable:
\begin{align}
    \xi_i &= \frac{u^*_{0i} - 1}{\gamma^*_i - 1} \label{eq-xi-helper}
\end{align}

The complete solutions are:

\begin{align}
    u^*_{ij} &= 1 + (u^*_{0i} - 1) e^{-t^*_j} \\
    {s^{\ast}}^{k}_{ij} &= 
      \begin{cases}
        \frac{1}{\gamma^{\ast}_i} + 
        \left( s^{\ast}_{0i} - \xi_i - \frac{1}{\gamma^{\ast}_i} \right) \cdot e^{-\gamma^{\ast}_i {t^{\ast}}^k_j} + 
        \xi_i \cdot e^{-{t^{\ast}}^k_j},& \gamma^{\ast}_i \neq 1 \\

        1 + (s^{\ast}_{0i} - 1) e^{-{t^{\ast}}^k_j} + 
          (u^{\ast}_{0i} - 1) {t^{\ast}}^k_j e^{-{t^{\ast}}^k_j},& \gamma^{\ast}_i = 1 \\
      \end{cases}, \label{eq-s-star-model-cell}
\end{align}

**Poisson observation model with characteristic scaling:**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \label{eq-dimless-u-obs-poisson}, \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij}) \label{eq-dimless-s-obs-poisson}
\end{align}

where:

- $i \in \{1, \ldots, G\}$ indexes genes
- $j \in \{1, \ldots, N\}$ indexes cells
- $t^*_j$ are observed dimensionless time coordinates for each cell
- $u^*_{0i}, s^*_{0i}$ are dimensionless initial conditions for each gene
- $u^*_{ij}, s^*_{ij}$ are the latent dimensionless RNA concentrations
- $U_{0i}$ is the characteristic concentration scale for gene $i$
- $\lambda_j$ is the lumped effective capture efficiency for cell $j$

### Parameter Interpretability

The dimensionless approach provides **natural identifiability** and **clear biological interpretation** for all inferred parameters:

#### **Core Dimensionless Parameters (Gene-Specific)**

**$\gamma^*_i$ (Relative degradation rate)**

- **Definition**: $\gamma^*_i = \gamma_i / \beta_i$
- **Interpretation**: How fast mRNA degrades relative to how fast pre-mRNA gets spliced
- **Biological meaning**:
  - $\gamma^*_i < 1$: mRNA is more stable than pre-mRNA processing time
  - $\gamma^*_i = 1$: mRNA degradation matches splicing timescale (special case)
  - $\gamma^*_i > 1$: mRNA degrades faster than splicing occurs
- **Special case**: When $\gamma^*_i = 1$, the analytical solution has a different form with a $t^*_j e^{-t^*_j}$ term
- **Helper variable**: $\xi_i = \frac{u^*_{0i} - 1}{\gamma^*_i - 1}$ (undefined when $\gamma^*_i = 1$)
- **Example**: $\gamma^*_i = 0.5$ means mRNA half-life is twice as long as the characteristic splicing time

#### **Characteristic Scales (Gene-Specific)**

**$U_{0i}$ (Characteristic concentration scale)**

- **Definition**: $U_{0i} = \alpha_i / \beta_i$
- **Units**: molecules/cell
- **Interpretation**: The steady-state pre-mRNA level that would be reached if there were no degradation
- **Biological meaning**: Represents the gene's "expression capacity" - how many molecules it can produce per splicing timescale
- **Example**: $U_{0i} = 100$ molecules/cell means this gene's transcription-splicing balance produces ~100 molecules per characteristic time

#### **Effective Capture Efficiency (Cell-Specific)**

**$\lambda_j$ (Lumped effective capture efficiency)**

- **Definition**: Cell-specific composite technical efficiency
- **Units**: Dimensionless (positive real number)
- **Interpretation**: Overall efficiency of detecting RNA molecules in cell $j$
- **Technical factors lumped together**:
  1. **True capture efficiency**: Fraction of molecules actually captured during library prep
  2. **Library size effects**: Total sequencing depth for this cell
  3. **Batch effects**: Systematic differences between experimental batches
  4. **Cell quality**: Cell viability, membrane integrity, RNA degradation
  5. **Ambient RNA**: Background contamination (modeled as scaling factor)
  6. **Technical dropout**: Stochastic detection failures
- **Example**: $\lambda_j = 0.5$ indicates this cell has 50% of the expected detection efficiency compared to a "reference" cell

#### **Derived Biological Quantities**

From the inferred parameters, you can reconstruct the original dimensional parameters:

**$\alpha_i$ (Transcription rate)**

- **Formula**: $\alpha_i = U_{0i} / T_{0i}$ (where $T_{0i} = 1/\beta_i$ is inferred from time scale)
- **Units**: molecules/(cell·hour)
- **Interpretation**: How many pre-mRNA molecules are transcribed per hour

**$\beta_i$ (Splicing rate)**

- **Formula**: $\beta_i = 1 / T_{0i}$ (from dimensionless time scale)
- **Units**: hour⁻¹
- **Interpretation**: Splicing rate constant

**$\gamma_i$ (Degradation rate)**

- **Formula**: $\gamma_i = \gamma^*_i \cdot \beta_i$
- **Units**: hour⁻¹
- **Interpretation**: mRNA degradation rate constant

### Justification for Parameterization

This parameterization is designed to optimally account for identifiability and known biological/technical considerations:

#### **Natural Identifiability**

- **Dimensionless approach**: Eliminates scaling symmetries inherent in dimensional models
- **No post-estimation rescaling**: Parameters are naturally identifiable during inference
- **Hierarchical priors**: Provide regularization without breaking identifiability

#### **Biological Interpretability**

- **$\gamma^*_i$**: Directly interpretable relative degradation rate
- **$U_{0i}$**: Gene expression capacity with clear biological meaning
- **Dimensionless solutions**: Universal dynamics independent of absolute scales

#### **Technical Factor Management**

- **Strategic lumping**: $\lambda_j$ captures multiple technical effects without overparameterization
- **Computational efficiency**: Fewer parameters than separate modeling of each technical factor
- **Robustness**: Works across different experimental protocols and platforms

#### **Connection to Established Theory**

- **Dimensional analysis**: Follows Buckingham π theorem for parameter reduction
- **RNA velocity theory**: Maintains connection to established dynamical systems approach
- **Single-cell best practices**: Accounts for known technical factors in scRNA-seq data

This approach attempts to balance **biological interpretability**, **statistical identifiability**, and **practical implementation**.

### Parameter Recovery Validation

```{python}
#| label: dimensional-count-validation
#| code-fold: true

# Create the simple deterministic model with validation functionality
# model = create_simple_deterministic_model_with_validation()

# # Configure validation parameters
# validation_config = ParameterRecoveryConfig(
#     num_parameter_sets=5,       # Number of parameter sets to test
#     sample_sizes=[50, 100, 200], # Different sample sizes
#     noise_levels=[0.1, 0.2],    # Different noise levels
#     inference_algorithm="SVI",   # Use SVI for speed
#     num_samples=1000,           # Number of inference samples
#     seed=42,                    # Random seed
# )

# # Run parameter recovery validation using registry-based validation components
# report = model.validate_parameter_recovery(validation_config)

# print(f"Validation completed!")
# print(f"Tested {len(report['parameter_sets'])} parameter sets")
# print(f"Overall parameter recovery success rate: {report['summary']['overall_success_rate']:.2%}")

# # Quick validation for development
# quick_results = model.quick_validation(num_genes=3, num_cells=50, noise_level=0.1)
# print(f"Quick validation success rate: {quick_results['summary']['overall_success_rate']:.2%}")

# # List available validation components
# print(f"Available validation components: {model.list_validation_components()}")
```

## Dimensionless analytical dynamics with latent time {#sec-dimless-latent-time}

This validation study extends the dimensionless approach to include **latent time coordinates** that must be inferred along with other parameters. We implement a hierarchical time structure that maintains biological interpretability while ensuring statistical identifiability.

### Model Description

The model uses the same dimensionless dynamics and observation model as the model described in @sec-dimless-observed-time, but replaces observed time coordinates with **hierarchical latent time coordinates**. This approach borrows strength across cells while allowing individual temporal variation.

### Probabilistic Graphical Model

The probabilistic graphical model now includes hierarchical priors for latent dimensionless time coordinates, with time parameters becoming random variables rather than observed quantities.

```{python}
#| label: fig-latent-time-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with hierarchical latent time coordinates.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters for gene-specific parameters
pgm.add_node("mu_init", r"$\mu_{0}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_init", r"$\sigma_{0}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)

# hyperparameters for hierarchical time structure
pgm.add_node("alpha_T", r"$\alpha_{T}$", 5.5, 6, fixed=True)
pgm.add_node("beta_T", r"$\beta_{T}$", 6, 6, fixed=True)
pgm.add_node("alpha_t_loc", r"$\alpha_{t_{loc}}$", 6.5, 6, fixed=True)
pgm.add_node("beta_t_loc", r"$\beta_{t_{loc}}$", 7, 6, fixed=True)
pgm.add_node("alpha_t_scale", r"$\alpha_{t_{scl}}$", 7.5, 6, fixed=True)
pgm.add_node("beta_t_scale", r"$\beta_{t_{scl}}$", 8, 6, fixed=True)

# hyperparameters for lambda (entering from right edge of cell plate)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 6.5, 3.5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 6.5, 2.5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("u_star_0i", r"$u^{\ast}_{0i}$", 1, 5)
pgm.add_node("s_star_0i", r"$s^{\ast}_{0i}$", 2, 5)
pgm.add_node("gamma_star_i", r"$\gamma^{\ast}_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# hierarchical time parameters (moved further left)
pgm.add_node("T_max_star", r"$T_{M}^*$", 5.5, 5)
pgm.add_node("t_loc", r"$t_{loc}$", 6.25, 5)
pgm.add_node("t_scale", r"$t_{scl}$", 7, 5)

# latent time coordinates and cell-specific parameters (moved further left, lambda enters from right)
pgm.add_node("t_star_j", r"$t^{\ast}_j$", 5.5, 4)
pgm.add_node("lambda_j", r"$\lambda_j$", 5.5, 3)

# latent variables for cell-specific outcomes (centered between rows)
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    3.75,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    3.75,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.25,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.25,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}

# gene-specific parameter edges
pgm.add_edge("mu_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "u_star_0i", plot_params=edge_params)
pgm.add_edge("mu_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("sigma_init", "s_star_0i", plot_params=edge_params)
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

# hierarchical time structure edges
pgm.add_edge("alpha_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max_star", plot_params=edge_params)
pgm.add_edge("alpha_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("beta_t_loc", "t_loc", plot_params=edge_params)
pgm.add_edge("alpha_t_scale", "t_scale", plot_params=edge_params)
pgm.add_edge("beta_t_scale", "t_scale", plot_params=edge_params)

# time hierarchy edges
pgm.add_edge("T_max_star", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_loc", "t_star_j", plot_params=edge_params)
pgm.add_edge("t_scale", "t_star_j", plot_params=edge_params)

# dynamics edges
pgm.add_edge("u_star_0i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("s_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("u_star_0i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.25, 4.5, 4.25],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.5, 1.75, 4.5, 2.75],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model extends the dimensionless approach with **hierarchical latent time coordinates**. The key modification is replacing observed time $t^*_j$ with latent time variables that follow a hierarchical prior structure.

**Priors for dimensionless parameters (unchanged from Study 1):**
\begin{align}
    u^*_{0i}, s^*_{0i} &\sim \text{LogNormal}(\mu_{0}, \sigma_{0}^2) \\
    \gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \\
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \\
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
\end{align}

**Hierarchical priors for latent time coordinates:**
\begin{align}
    T_{M}^* &\sim \text{Gamma}(\alpha_{T}, \beta_{T}) \label{eq-T-M-prior} \\
    t_{loc} &\sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}}) \label{eq-t-loc-prior} \\
    t_{scl} &\sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}}) \label{eq-t-scl-prior} \\
    \tilde{t}_j &\sim \text{Normal}(t_{loc}, t_{scl}^2) \quad \text{for } j \in \{1, \ldots, N\} \label{eq-t-tilde-prior} \\
    t^*_j &= T_{M}^* \times \max(\tilde{t}_j, \epsilon) \quad \text{(clipped transformation)} \label{eq-t-star-transform}
\end{align}

$\tilde{t}_j$ represents the **relative temporal position** of cell $j$ within the population distribution, and $t^*_j$ represents the **actual dimensionless time coordinate**. The clipping operation $\max(\tilde{t}_j, \epsilon)$ with $\epsilon = 10^{-5}$ ensures that all time coordinates remain positive, maintaining biological realism (cells cannot be "before" the process) and mathematical consistency with the analytical solutions. While $\tilde{t}_j$ is not explicitly shown in the PGM for space constraints, the clipped transformation is implicitly included in the $t^*_j$ node.

**Dimensionless analytical solutions (unchanged):**
The same analytical solutions from Study 1 apply, but now using latent $t^*_j$:
\begin{align}
    u^*_{ij} &= 1 + (u^*_{0i} - 1) e^{-t^*_j} \\
    s^*_{ij} &= \begin{cases}
        \frac{1}{\gamma^*_i} + \left(s^*_{0i} - \xi_i - \frac{1}{\gamma^*_i}\right) e^{-\gamma^*_i t^*_j} + \xi_i e^{-t^*_j} & \text{if } \gamma^*_i \neq 1 \\
        1 + (s^*_{0i} - 1) e^{-t^*_j} + (u^*_{0i} - 1) t^*_j e^{-t^*_j} & \text{if } \gamma^*_i = 1
    \end{cases}
\end{align}

where $\xi_i = \frac{u^*_{0i} - 1}{\gamma^*_i - 1}$.

**Observation model (unchanged):**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij})
\end{align}

### Hierarchical Time Parameter Interpretability

The hierarchical time structure introduces new parameters with clear biological and statistical interpretations:

#### **Global Time Scale Parameters**

**$T_{M}^*$ (Global dimensionless time scale)**

- **Definition**: Global scaling factor for dimensionless time coordinates
- **Units**: Dimensionless (in units of characteristic splicing time)
- **Interpretation**: Characteristic temporal extent of the biological process
- **Biological meaning**: Represents the typical time scale over which the biological process unfolds
- **Model role**: Multiplicative scaling factor in $t^*_j \sim T_{M}^* \times \text{Normal}(t_{loc}, t_{scl}^2)$
- **Prior**: $T_{M}^* \sim \text{Gamma}(\alpha_{T}, \beta_{T})$ ensures positive values with flexible tail behavior
- **Example**: $T_{M}^* = 5$ means the process typically spans ~5 characteristic splicing times

#### **Population-Level Time Parameters**

**$t_{loc}$ (Population relative time location)**

- **Definition**: Population-level location parameter for relative time distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: Central tendency of where cells are located in relative time
- **Biological meaning**: Typical relative temporal position of cells in the biological process
- **Prior**: $t_{loc} \sim \text{Gamma}(\alpha_{t_{loc}}, \beta_{t_{loc}})$ ensures positive location with flexible shape
- **Statistical role**: Allows borrowing strength across cells while permitting individual variation
- **Example**: $t_{loc} = 0.7$ means cells are typically positioned at 70% through the relative process timeline

**$t_{scl}$ (Population relative time scale)**

- **Definition**: Population-level scale parameter for relative time distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: How much relative temporal variation exists across cells
- **Biological meaning**: Degree of temporal heterogeneity in the cell population
- **Prior**: $t_{scl} \sim \text{Gamma}(\alpha_{t_{scl}}, \beta_{t_{scl}})$ ensures positive scale with flexible shape
- **Statistical role**: Controls the amount of shrinkage toward the population mean
- **Example**: $t_{scl} = 0.2$ indicates relatively tight temporal clustering around $t_{loc}$

#### **Cell-Specific Time Coordinates**

**$\tilde{t}_j$ (Cell-specific relative time)**

- **Definition**: Latent relative time coordinate for cell $j$ within the population distribution
- **Units**: Dimensionless (relative time units)
- **Interpretation**: Cell's position relative to the population temporal distribution
- **Biological meaning**: Where this cell sits in the relative temporal progression
- **Prior**: $\tilde{t}_j \sim \text{Normal}(t_{loc}, t_{scl}^2)$ allows natural population variation
- **Range**: Can be negative (before typical process) or greater than 1 (after typical process)
- **Example**: $\tilde{t}_j = -0.2$ means this cell would be before the typical process start; $\tilde{t}_j = 1.3$ means after typical completion

**$t^*_j$ (Cell-specific dimensionless time)**

- **Definition**: Actual dimensionless time coordinate for cell $j$ after clipping
- **Units**: Dimensionless (in units of characteristic splicing time)
- **Interpretation**: How many splicing events have elapsed for this specific cell
- **Biological meaning**: Cell's absolute position along the temporal trajectory of the biological process
- **Transformation**: $t^*_j = T_{M}^* \times \max(\tilde{t}_j, \epsilon)$ with $\epsilon = 10^{-5}$
- **Constraint**: Always positive, ensuring mathematical consistency with analytical solutions
- **Example**: If $T_{M}^* = 5$, $\tilde{t}_j = 0.6$, then $t^*_j = 3.0$ characteristic splicing times; if $\tilde{t}_j = -0.1$, then $t^*_j = 5 \times 10^{-5}$ (clipped)

### Properties of Gamma/Normal Hierarchical Time Structure

#### **Statistical Benefits**

- **Improved identifiability**: Hierarchical structure provides regularization without redundant parameters
- **Borrowing strength**: Information shared across cells improves parameter estimation
- **Uncertainty quantification**: Full posterior distributions for all time parameters
- **Robustness**: Less sensitive to outlier cells or sparse data
- **No truncation constraints**: Avoids computational complexity of truncated distributions
- **Clear parameter roles**: $T_{M}^*$ controls global scale, $t_{loc}$ and $t_{scl}$ control population distribution

#### **Biological Interpretability**

- **Dimensionless time**: Universal interpretation across experimental conditions
- **Population heterogeneity**: Captures natural variation in biological timing
- **Individual trajectories**: Each cell has its own temporal position
- **Flexible temporal range**: $\tilde{t}_j$ can represent cells before or after the typical process timeline
- **Biological realism**: Clipping ensures cells cannot be "before" the process start ($t^*_j \geq \epsilon$)
- **Mathematical consistency**: Positive time coordinates maintain validity of analytical solutions

#### **Computational Efficiency**

- **Standard distributions**: Gamma and Normal distributions are computationally efficient
- **No truncation**: Avoids complex truncated distribution sampling
- **Simple clipping**: $\max(\tilde{t}_j, \epsilon)$ operation is computationally trivial
- **Analytical solutions**: Fast likelihood evaluation for validation
- **Hierarchical sampling**: Efficient MCMC mixing through population-level parameters
- **Deterministic transformation**: $t^*_j = T_{M}^* \times \max(\tilde{t}_j, \epsilon)$ is simple and fast

## Dimensionless Analytical Dynamics with Latent Time and Piecewise Activation {#sec-dimless-latent-piecewise}

This validation study introduces **piecewise constant transcription rates** while maintaining analytical tractability and resolving critical dimensional analysis inconsistencies identified in the piecewise activation framework. The key innovation is a **dimensionally consistent parameterization** that eliminates parameter redundancy by fixing the reference transcription state, while maintaining biological interpretability through fold-change parameters. Additionally, this study implements a **process duration with stick-breaking** temporal framework that eliminates scaling symmetry and achieves parameter identifiability while preserving all analytical and computational advantages.

### Model Description

The model extends Study 2 by replacing the constant transcription rate $\alpha^* = 1$ with a **piecewise constant transcription function** $\alpha^*_i(t^*)$ that varies over time for each gene. To resolve dimensional analysis violations, we implement a **constrained parameterization** where the off-state transcription rate serves as a fixed reference ($\alpha^*_{\text{off}i} = 1.0$), eliminating parameter redundancy while maintaining biological interpretability through fold-change parameters.

### Dimensionally Consistent Piecewise Framework

#### Reference State Parameterization

To eliminate parameter redundancy identified in the dimensional analysis, we fix the off-state as a reference:

$$\alpha^*_{\text{off}i} = 1.0 \quad \text{(fixed reference, not inferred)}$$

This choice establishes a **consistent dimensional reference** where $U_{0i}$ unambiguously represents the characteristic concentration scale corresponding to the off-state transcription rate.

#### Extended Temporal Framework with Pre-Activation

To accommodate realistic gene expression scenarios, including genes that are already activated when observation begins, we extend the temporal framework to allow **negative onset times**.

#### Piecewise Transcription Rate Function

For each gene $i$, the dimensionless transcription rate follows a three-phase piecewise constant function:

$$\alpha^*_i(t^*) := \begin{cases}
1.0 & \text{if } t^* < t^*_{0,\text{on}i}, \\
R_{\text{on},i} & \text{if } t^*_{0,\text{on}i} \leq t^* < t^*_{0,\text{on}i} + \delta^*_i, \\
1.0 & \text{if } t^* \geq t^*_{0,\text{on}i} + \delta^*_i
\end{cases}$$

where:

- $\alpha^*_{\text{off}i} = 1.0$ is the fixed reference transcription rate
- $R_{\text{on},i} = \alpha^*_{\text{on}i}/\alpha^*_{\text{off}i} = \alpha^*_{\text{on}i}$ is the fold-change during activation (inferred parameter)
- $t^*_{0,\text{on}i}$ is the dimensionless activation onset time (can be negative for pre-activation scenarios)
- $\delta^*_i$ is the dimensionless activation duration

#### Biological Interpretation of Negative Onset Times

When $t^*_{0,\text{on}i} < 0$:

- The gene was **already activated** before observation began ($t^* = 0$)
- Cells at early timepoints may show **high expression** for such genes
- The model captures **pre-existing activation states** in addition to activation events during observation
- **Biological examples**: Early developmental genes already active when profiling begins, stress response genes in cells experiencing ongoing stress, lineage commitment factors in partially committed progenitors

### Steady-State Initial Conditions

Initial conditions are fixed to the off-state steady-state values:

$$u^*_{0i} = 1.0, \quad s^*_{0i} = \frac{1.0}{\gamma^*_i} = \frac{1}{\gamma^*_i}$$

This eliminates the need to infer $u^*_{0i}$ and $s^*_{0i}$ as separate parameters while providing equivalent modeling flexibility through the characteristic scale $U_{0i}$ and fold-change $R_{\text{on},i}$.

### Analytical Solutions for Each Phase

The dimensionless system with piecewise activation becomes:

\begin{align}
\frac{du^{\ast}}{dt^{\ast}} &= \alpha^*_i(t^*) - u^{\ast} \\
\frac{ds^{\ast}}{dt^{\ast}} &= u^{\ast} - \gamma^{\ast}_i s^{\ast}
\end{align}

We solve this system analytically for each of the three phases:

#### **Phase 1: Off State** ($t^* < t^*_{0,\text{on}i}$)

With constant transcription rate $\alpha^*_{\text{off}i} = 1.0$ and initial conditions at steady state, the system remains at equilibrium:

\begin{align}
u^*_{ij}(t^*) &= 1.0 \\
s^*_{ij}(t^*) &= \frac{1.0}{\gamma^*_i}
\end{align}

**Note**: This phase may not be observed if $t^*_{0,\text{on}i} < 0$ (pre-activation scenario).

#### **Phase 2: On State** ($t^*_{0,\text{on}i} \leq t^* < t^*_{0,\text{on}i} + \delta^*_i$)

Let $\tau_{\text{on}} = t^* - t^*_{0,\text{on}i}$ be the time since activation onset. The system transitions from the off-state steady state toward the on-state steady state.

**Initial conditions for Phase 2:**
$$u^*_{\text{on},0i} = 1.0, \quad s^*_{\text{on},0i} = \frac{1.0}{\gamma^*_i}$$

**Analytical solutions:**

For $\gamma^*_i \neq 1$:
\begin{align}
u^*_{ij}(\tau_{\text{on}}) &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\tau_{\text{on}}} \\
s^*_{ij}(\tau_{\text{on}}) &= \frac{R_{\text{on},i}}{\gamma^*_i} + \left(\frac{1.0}{\gamma^*_i} - \xi_{\text{on}i} - \frac{R_{\text{on},i}}{\gamma^*_i}\right) e^{-\gamma^*_i \tau_{\text{on}}} + \xi_{\text{on}i} e^{-\tau_{\text{on}}}
\end{align}

where $\xi_{\text{on}i} = \frac{1.0 - R_{\text{on},i}}{\gamma^*_i - 1}$.

For $\gamma^*_i = 1$:
\begin{align}
u^*_{ij}(\tau_{\text{on}}) &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\tau_{\text{on}}} \\
s^*_{ij}(\tau_{\text{on}}) &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\tau_{\text{on}}} + (1.0 - R_{\text{on},i}) \tau_{\text{on}} e^{-\tau_{\text{on}}}
\end{align}

**Special case interpretation ($\gamma^*_i = 1$):**

The case $\gamma^*_i = 1$ represents **balanced splicing-degradation kinetics** where mRNA degradation occurs at exactly the same rate as pre-mRNA splicing. This creates a mathematical resonance that fundamentally changes the system's dynamics:

- **Biological meaning**: The characteristic timescales for splicing ($1/\beta_i$) and degradation ($1/\gamma_i$) are identical
- **Mathematical consequence**: The standard exponential solutions become degenerate, requiring the additional $\tau_{\text{on}} e^{-\tau_{\text{on}}}$ term
- **Physical interpretation**: The $\tau e^{-\tau}$ term represents the accumulation of mRNA over time when production and degradation rates are perfectly balanced
- **Parameter recovery implications**: Inference near $\gamma^*_i = 1$ may exhibit slower convergence due to the discontinuous derivative in the analytical solutions
- **Numerical considerations**: The transition between $\gamma^*_i \neq 1$ and $\gamma^*_i = 1$ solutions requires careful handling to maintain numerical stability

#### **Phase 3: Return to Off State** ($t^* \geq t^*_{0,\text{on}i} + \delta^*_i$)

Let $\tau_{\text{off}} = t^* - (t^*_{0,\text{on}i} + \delta^*_i)$ be the time since returning to the off state. The system transitions from the end-of-phase-2 state back toward the off-state steady state.

**Initial conditions for Phase 3:**

The initial conditions for Phase 3 are the endpoint values from Phase 2, computed explicitly as:

For $\gamma^*_i \neq 1$:
\begin{align}
u^*_{\text{off},0i} &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\delta^*_i} \\
s^*_{\text{off},0i} &= \frac{R_{\text{on},i}}{\gamma^*_i} + \left(\frac{1.0}{\gamma^*_i} - \xi_{\text{on}i} - \frac{R_{\text{on},i}}{\gamma^*_i}\right) e^{-\gamma^*_i \delta^*_i} + \xi_{\text{on}i} e^{-\delta^*_i}
\end{align}

For $\gamma^*_i = 1$:
\begin{align}
u^*_{\text{off},0i} &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\delta^*_i} \\
s^*_{\text{off},0i} &= R_{\text{on},i} + (1.0 - R_{\text{on},i}) e^{-\delta^*_i} + (1.0 - R_{\text{on},i}) \delta^*_i e^{-\delta^*_i}
\end{align}

where $\xi_{\text{on}i} = \frac{1.0 - R_{\text{on},i}}{\gamma^*_i - 1}$ for the $\gamma^*_i \neq 1$ case.

**Analytical solutions:**

For $\gamma^*_i \neq 1$:
\begin{align}
u^*_{ij}(\tau_{\text{off}}) &= 1.0 + (u^*_{\text{off},0i} - 1.0) e^{-\tau_{\text{off}}} \\
s^*_{ij}(\tau_{\text{off}}) &= \frac{1.0}{\gamma^*_i} + \left(s^*_{\text{off},0i} - \xi_{\text{off}i} - \frac{1.0}{\gamma^*_i}\right) e^{-\gamma^*_i \tau_{\text{off}}} + \xi_{\text{off}i} e^{-\tau_{\text{off}}}
\end{align}

where $\xi_{\text{off}i} = \frac{u^*_{\text{off},0i} - 1.0}{\gamma^*_i - 1}$.

For $\gamma^*_i = 1$:
\begin{align}
u^*_{ij}(\tau_{\text{off}}) &= 1.0 + (u^*_{\text{off},0i} - 1.0) e^{-\tau_{\text{off}}} \\
s^*_{ij}(\tau_{\text{off}}) &= 1.0 + (s^*_{\text{off},0i} - 1.0) e^{-\tau_{\text{off}}} + (u^*_{\text{off},0i} - 1.0) \tau_{\text{off}} e^{-\tau_{\text{off}}}
\end{align}

### Process Duration with Stick-Breaking Framework

This study implements a **process duration with stick-breaking** approach that eliminates the scaling symmetry present in hierarchical temporal scaling while maintaining all analytical and biological advantages. The key innovation is the use of **fixed anchor points** that break scaling symmetry and achieve parameter identifiability.

#### **Elimination of Scaling Symmetry**

The previous hierarchical scaling approach suffered from fundamental **scaling symmetry** that prevented parameter identifiability:

$$\mathcal{L}(T_M^*, \{t^*_j\}, \{t^*_{0,\text{on}i}\}, \{\delta^*_i\}) = \mathcal{L}(\lambda T_M^*, \{\lambda t^*_j\}, \{\lambda t^*_{0,\text{on}i}\}, \{\lambda \delta^*_i\})$$

for any $\lambda > 0$. This symmetry creates non-identifiable parameters and leads to catastrophic validation failures.

#### **Fixed Anchor Point Solution**

The stick-breaking approach eliminates scaling symmetry through **fixed anchor points**:

\begin{align}
t^*_1 &= 0 \quad \text{(process start, fixed)} \\
t^*_N &= T_{\max} \quad \text{(process end, sampled)} \\
t^*_{0,\text{on}i} &\sim \text{Normal}(\mu_{\text{on}}, \sigma_{\text{on}}^2) \quad \text{(independent gene timing)} \\
\delta^*_i &\sim \text{LogNormal}(\mu_{\delta}, \sigma_{\delta}^2) \quad \text{(independent gene duration)}
\end{align}

**Theorem (Elimination of Scaling Symmetry):**

For any scaling factor $\lambda \neq 1$, the likelihood functions are not equal:
$$\mathcal{L}(T_{\max}, \{t^*_j\}, \{t^*_{0,\text{on}i}\}, \{\delta^*_i\}) \neq \mathcal{L}(\lambda T_{\max}, \{\lambda t^*_j\}, \{t^*_{0,\text{on}i}\}, \{\delta^*_i\})$$

**Proof:**
1. **Fixed anchor constraint**: The scaled system requires $t^*_1 = \lambda \cdot 0 = 0$ and $t^*_N = \lambda T_{\max}$
2. **Process duration independence**: Gene parameters $t^*_{0,\text{on}i}, \delta^*_i$ are sampled independently of $T_{\max}$ and do not scale
3. **Asymmetric scaling**: Scaling $T_{\max} \rightarrow \lambda T_{\max}$ and $t^*_j \rightarrow \lambda t^*_j$ changes the relative positioning of gene events within the process timeline
4. **Likelihood dependence**: The piecewise analytical solutions depend on comparisons like $t^*_j$ vs. $t^*_{0,\text{on}i}$, which change under asymmetric scaling

Therefore, the likelihood is not invariant under parameter scaling, eliminating the scaling symmetry. □

### Gene Expression Pattern Classification

This framework enables representation of diverse gene expression patterns through specific parameter combinations. Each pattern is defined by quantitative parameter ranges applied to **absolute temporal parameters** within the process duration framework.

**Parameter Framework**: The classification uses absolute temporal parameters that are independent of the process duration $T_{\max}$, enabling robust pattern identification across different experimental timescales.

#### **Pre-Activation Patterns**

**Characteristics**: Genes that were already activated before observation began, showing decay-only dynamics from an initially activated steady-state.

**Parameter specifications**:

- $t^*_{0,\text{on}i} < 0.0$ (activation onset before process start)
- $R_{\text{on},i} > 2.0$ (moderate to strong fold-change during activation)

**Biological interpretation**: These genes underwent activation before the biological process under study began ($t^* = 0$). During the observed period, they exhibit decay-only dynamics as they return toward baseline expression levels. The negative onset time indicates that activation occurred before the process boundary.

**Biological examples**: Early developmental genes, maternal transcripts during development, lineage commitment factors established before observation, stress response genes in ongoing stress conditions

#### **Transient Activation Patterns**

**Characteristics**: Genes that show complete activation-decay cycles within the process duration, exhibiting brief, pulse-like activation followed by return toward baseline.

**Parameter specifications**:

- $t^*_{0,\text{on}i} > 0.0$ (activation within process duration)
- $t^*_{0,\text{on}i} < 2.5$ (activation early enough to complete cycle within process)
- $\delta^*_i < 2.0$ (short activation duration relative to process)
- $R_{\text{on},i} > 2.0$ (sufficient fold-change to observe activation)

**Biological interpretation**: These genes activate early enough and for a short enough duration that the complete activation-decay cycle is observable within the process duration. The constraints ensure that both the activation and subsequent decay phases are captured within the temporal boundaries.

**Biological examples**: Immediate early genes, signaling molecules, transient developmental regulators, cell cycle checkpoint genes, acute stress response genes

#### **Sustained Activation Patterns**

**Characteristics**: Genes that become activated early and remain highly expressed throughout most of the process duration, showing net increase over the process timeline.

**Parameter specifications**:

- $t^*_{0,\text{on}i} > 0.0$ (activation within process duration)
- $t^*_{0,\text{on}i} < 1.5$ (early activation onset within process)
- $\delta^*_i > 2.5$ (long activation duration relative to process)
- $R_{\text{on},i} > 2.0$ (strong fold-change during activation)

**Biological interpretation**: These genes activate early in the process and maintain high expression levels throughout most of the process duration. The long activation duration means that decay back to baseline is either minimal or occurs beyond the process endpoint.

**Biological examples**: Lineage-specific transcription factors, structural proteins, metabolic enzymes, terminal differentiation markers, long-term stress adaptation genes

### Mathematical Framework for Pre-Activation Scenarios

The Normal prior for onset times enables modeling of **pre-activation scenarios** where genes are already activated when the biological process begins. This extension is mathematically valid and biologically realistic:

#### **Mathematical Validity of Negative Onset Times**

When $t^*_{0,\text{on}i} < 0$:

1. **Phase determination remains consistent**: For any process time $t^* \geq 0$, we can still determine which phase applies by comparing $t^*$ to $t^*_{0,\text{on}i}$ and $t^*_{0,\text{on}i} + \delta^*_i$

2. **Analytical solutions remain valid**: All exponential solutions are well-defined for negative onset times

3. **Biological interpretation is clear**: Negative onset simply means activation occurred before the process start ($t^* = 0$)

#### **Implementation Considerations**

- **Phase 1 may be unobserved**: If $t^*_{0,\text{on}i} < 0$, no cells will be in Phase 1 during the process
- **Phase 2 starts immediately**: Cells at $t^* = 0$ may already be in the activated state
- **Duration constraints**: For pre-activation genes, $\delta^*_i > |t^*_{0,\text{on}i}|$ ensures activation extends into the process duration

### Constraint Feasibility Analysis and Optimization

The pattern constraints above were optimized using a systematic CDF-based analysis to ensure mathematical feasibility while preserving biological interpretability. The analysis now includes both LogNormal and Normal distributions to handle the extended temporal framework.

#### **Mathematical Framework for Constraint Analysis**

For each pattern constraint, we calculate the probability that a parameter sampled from its prior distribution satisfies the constraint using cumulative distribution functions (CDFs).

For **LogNormal parameters** ($R_{\text{on},i}$, $\delta^*_i$), the probability of satisfying constraint $X > \theta$ is:

$$P(X > \theta) = 1 - \Phi\left(\frac{\log(\theta) - \mu}{\sigma}\right)$$

For **Normal parameters** ($t^*_{0,\text{on}i}$), the probability of satisfying constraint $X > \theta$ is:

$$P(X > \theta) = 1 - \Phi\left(\frac{\theta - \mu}{\sigma}\right)$$

where $\Phi$ is the standard normal CDF. The joint probability of satisfying all constraints for a pattern is the product of individual constraint probabilities (assuming independence).

#### **Constraint Feasibility Assessment**

```{python}
#| code-fold: true
#| code-summary: "Show/Hide Code"
#| eval: false

# CDF-based feasibility analysis for pattern constraints
from scipy import stats
import numpy as np

def calculate_lognormal_cdf_probability(loc, scale, threshold, upper=True):
    """Calculate P(X > threshold) or P(X < threshold) for LogNormal(loc, scale)."""
    if upper:
        return 1 - stats.lognorm.cdf(threshold, s=scale, scale=np.exp(loc))
    else:
        return stats.lognorm.cdf(threshold, s=scale, scale=np.exp(loc))

def calculate_normal_cdf_probability(loc, scale, threshold, upper=True):
    """Calculate P(X > threshold) or P(X < threshold) for Normal(loc, scale)."""
    if upper:
        return 1 - stats.norm.cdf(threshold, loc=loc, scale=scale)
    else:
        return stats.norm.cdf(threshold, loc=loc, scale=scale)

# Prior hyperparameters (updated for absolute temporal parameterization)
priors = {
    'R_on': {'loc': 0.916, 'scale': 0.4},              # log(2.5), fold-change (LogNormal)
    't_on_star': {'loc': 2.5, 'scale': 1.5},           # Normal(2.5, 1.5²), absolute onset (allows negatives)
    'delta_star': {'loc': 0.0, 'scale': 0.5},          # log(1.0), absolute duration (LogNormal)
}

# Calculate constraint feasibility for each pattern (updated for absolute parameterization)
patterns = {
    'pre_activation': [
        ('t_on_star', '<', 0.0),        # Activation before process start
        ('R_on', '>', 2.0),             # Moderate to strong fold change
    ],
    'transient': [
        ('t_on_star', '>', 0.0),        # Activation within process duration
        ('t_on_star', '<', 2.5),        # Early enough to complete cycle
        ('delta_star', '<', 2.0),       # Short pulse duration
        ('R_on', '>', 2.0),             # Sufficient fold change to observe
    ],
    'sustained': [
        ('t_on_star', '>', 0.0),        # Activation within process duration
        ('t_on_star', '<', 1.5),        # Early activation onset
        ('delta_star', '>', 2.5),       # Long activation duration
        ('R_on', '>', 2.0),             # Strong fold change
    ]
}

for pattern_name, constraints in patterns.items():
    joint_prob = 1.0
    print(f"\n{pattern_name.upper()} PATTERN:")

    for param, op, threshold in constraints:
        prior = priors[param]

        if param == 't_on_star':  # Normal distribution
            prob = calculate_normal_cdf_probability(
                prior['loc'], prior['scale'], threshold, upper=(op == '>')
            )
        else:  # LogNormal distribution
            prob = calculate_lognormal_cdf_probability(
                prior['loc'], prior['scale'], threshold, upper=(op == '>')
            )

        joint_prob *= prob
        print(f"  P({param} {op} {threshold}) = {prob:.3f}")

    print(f"  Joint probability: {joint_prob:.3f}")
```

### Probabilistic Graphical Model

The probabilistic graphical model implements the process duration with stick-breaking framework while adding gene-specific piecewise activation parameters. For visual clarity, we use $\theta_i$ to represent the vector of non-temporal piecewise activation parameters $(\gamma^*_i, R_{\text{on},i})$ and $\Delta_i$ to represent the vector of absolute temporal gene parameters $(t^*_{0,\text{on}i}, \delta^*_i)$. Note that $\alpha^*_{\text{off}i} = 1.0$ is fixed and not shown as a random variable.

```{python}
#| label: fig-piecewise-activation-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with hierarchical latent time coordinates and piecewise activation.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 16
plt.rcParams["text.usetex"] = True

pgm = daft.PGM(line_width=1.2)

# hyperparameters for gene-specific parameters
pgm.add_node("mu_theta", r"$\mu_{\theta}$", 0.5, 6, fixed=True)
pgm.add_node("sigma_theta", r"$\sigma_{\theta}^2$", 1.5, 6, fixed=True)
pgm.add_node("mu_Delta", r"$\mu_{\Delta}$", 2.5, 6, fixed=True)
pgm.add_node("sigma_Delta", r"$\sigma_{\Delta}^2$", 3.5, 6, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 6, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 6, fixed=True)

# hyperparameters for process duration
pgm.add_node("alpha_T", r"$\alpha_{T}$", 5.5, 6, fixed=True)
pgm.add_node("beta_T", r"$\beta_{T}$", 6, 6, fixed=True)

# hyperparameters for lambda (entering from right edge of cell plate)
pgm.add_node("mu_lambda", r"$\mu_{\lambda}$", 7.5, 3.5, fixed=True)
pgm.add_node("sigma_lambda", r"$\sigma_{\lambda}^2$", 7.5, 2.5, fixed=True)

# latent variables for gene-specific parameters
pgm.add_node("theta_i", r"$\theta_i$", 1, 5)
pgm.add_node("Delta_i", r"$\Delta_i$", 3, 5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5)

# process duration parameter (replaces hierarchical time scaling)
pgm.add_node("T_max", r"$T_{\max}$", 5.5, 5)

# stick-breaking cell times and cell-specific parameters
pgm.add_node("t_star_j", r"$t^{\ast}_j$", 5.5, 4)
pgm.add_node("lambda_j", r"$\lambda_j$", 6.5, 3)

# latent variables for cell-specific outcomes (centered between rows)
pgm.add_node(
    "u_star_ij",
    r"$u^{\ast}_{ij}$",
    2,
    3.75,
    scale=1.0,
    shape="rectangle",
)
pgm.add_node(
    "s_star_ij",
    r"$s^{\ast}_{ij}$",
    4,
    3.75,
    scale=1.0,
    shape="rectangle",
)

# observed data
pgm.add_node(
    "u_obs_ij",
    r"$u_{ij}$",
    2,
    2.25,
    scale=1.0,
    observed=True,
)
pgm.add_node(
    "s_obs_ij",
    r"$s_{ij}$",
    4,
    2.25,
    scale=1.0,
    observed=True,
)

# edges
edge_params = {"head_length": 0.3, "head_width": 0.25, "lw": 0.7}

# gene-specific parameter edges
pgm.add_edge("mu_theta", "theta_i", plot_params=edge_params)
pgm.add_edge("sigma_theta", "theta_i", plot_params=edge_params)
pgm.add_edge("mu_Delta", "Delta_i", plot_params=edge_params)
pgm.add_edge("sigma_Delta", "Delta_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("mu_lambda", "lambda_j", plot_params=edge_params)
pgm.add_edge("sigma_lambda", "lambda_j", plot_params=edge_params)

# process duration edges
pgm.add_edge("alpha_T", "T_max", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max", plot_params=edge_params)

# stick-breaking time edges
pgm.add_edge("T_max", "t_star_j", plot_params=edge_params)

# dynamics edges
pgm.add_edge("theta_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("theta_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("Delta_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("Delta_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate(
    [0.5, 1.25, 4.5, 4.25],
    label=r"$i \in \{1, \ldots, G\}$",
    shift=-0.1,
    fontsize=12,
)
pgm.add_plate(
    [1.5, 1.75, 4.5, 2.75],
    label=r"$j \in \{1, \ldots, N\}$",
    shift=-0.1,
    fontsize=12,
)

pgm.render()
```

### Mathematical Description

The model combines the process duration with stick-breaking framework with piecewise constant transcription rates and steady-state initial conditions to achieve parameter identifiability while enabling rich gene expression dynamics.

**Notation mapping between PGM and mathematical description:**

In the PGM above, we use simplified notation for visual clarity:

- $\theta_i$ represents the vector of **non-temporal** piecewise activation parameters $(\gamma^*_i, R_{\text{on},i})$
- $\Delta_i$ represents the vector of **absolute temporal** gene parameters $(t^*_{0,\text{on}i}, \delta^*_i)$
- The hyperparameters $\mu_{\theta}, \sigma_{\theta}^2$ represent the collection of hyperparameters for all components of $\theta_i$
- The hyperparameters $\mu_{\Delta}, \sigma_{\Delta}^2$ represent the collection of hyperparameters for all components of $\Delta_i$
- $T_{\max}$ represents the total process duration with fixed anchor points at $t^*_1 = 0$ and $t^*_N = T_{\max}$
- $\alpha^*_{\text{off}i} = 1.0$ is fixed and not shown as a random variable
- Gene temporal parameters are sampled independently of $T_{\max}$, eliminating scaling symmetry

**Detailed priors for process duration with stick-breaking framework:**

The priors are designed to encode biologically reasonable parameter ranges while achieving parameter identifiability through fixed anchor points and independent gene timing:

**Process duration:**
\begin{align}
    T_{\max} &\sim \text{Gamma}(5.0, 1.0) \quad \text{(total process duration)}
\end{align}

**Non-temporal gene-specific parameters:**
\begin{align}
    \gamma^*_i &\sim \text{LogNormal}(\log(1.0), 0.5^2) \quad \text{(relative degradation rate)} \\
    R_{\text{on},i} &\sim \text{LogNormal}(\log(2.5), 0.4^2) \quad \text{(activation fold-change)}
\end{align}

**Absolute temporal gene-specific parameters (independent of $T_{\max}$):**
\begin{align}
    t^*_{0,\text{on}i} &\sim \text{Normal}(2.5, 1.5^2) \quad \text{(absolute activation onset time)} \\
    \delta^*_i &\sim \text{LogNormal}(0.0, 0.5^2) \quad \text{(absolute activation duration)}
\end{align}

**Stick-breaking cell times:**
\begin{align}
    t^*_1 &= 0 \quad \text{(process start, fixed)} \\
    t^*_N &= T_{\max} \quad \text{(process end)} \\
    \xi_j &\sim \text{Beta}(1, N-j) \quad \text{for } j \in \{2, \ldots, N-1\} \\
    t^*_j &= t^*_{j-1} + \xi_{j-1}(T_{\max} - t^*_{j-1}) \quad \text{(recursive construction)}
\end{align}

**Pattern Classification with Absolute Parameters:**

Using the expected process duration $\mathbb{E}[T_{\max}] = 5.0$, the pattern constraints become:

- **Pre-activation**: $t^*_{0,\text{on}i} < 0.0$ and $R_{\text{on},i} > 2.0$ (gene activated before process begins)
- **Transient**: $0.0 < t^*_{0,\text{on}i} < 2.5$ and $\delta^*_i < 2.0$ and $R_{\text{on},i} > 2.0$ (complete cycle within process)
- **Sustained**: $0.0 < t^*_{0,\text{on}i} < 1.5$ and $\delta^*_i > 2.5$ and $R_{\text{on},i} > 2.0$ (long-duration activation)

These absolute thresholds preserve the same biological pattern meanings as the original relative formulation.

**Biological interpretation of prior choices:**

**Process duration:**

- **$T_{\max} \sim \text{Gamma}(5.0, 1.0)$**: Centers process duration at 5 dimensionless time units, providing sufficient range for exponential convergence while maintaining computational efficiency. The process has clear start ($t^* = 0$) and end ($t^* = T_{\max}$) boundaries.

**Non-temporal parameters:**

- **$\gamma^*_i \sim \text{LogNormal}(\log(1.0), 0.5^2)$**: Centers relative degradation around 1 (balanced splicing/degradation), with 95% of values between ~0.37 and ~2.7.

- **$R_{\text{on},i} \sim \text{LogNormal}(\log(2.5), 0.4^2)$**: Centers fold-change at 2.5× during activation, with 95% between ~1.5 and ~4.2.

**Absolute temporal parameters:**

- **$t^*_{0,\text{on}i} \sim \text{Normal}(2.5, 1.5^2)$**: Centers activation onset at the middle of the expected process duration, with 95% between approximately -0.4 and +5.4. **Negative values** enable pre-activation scenarios where genes were already activated before the process began.

- **$\delta^*_i \sim \text{LogNormal}(0.0, 0.5^2)$**: Centers activation duration at 1 dimensionless time unit, with 95% between ~0.37 and ~2.7. This enables both transient (short duration) and sustained (long duration) activation patterns.

**Pattern classification implications:**

- **Pre-activation** ($t^*_{0,\text{on}i} < 0$): ~4.8% probability under the prior
- **Transient** ($0 < t^*_{0,\text{on}i} < 2.5$ and $\delta^*_i < 2.0$): Balanced probability for observable complete cycles
- **Sustained** ($0 < t^*_{0,\text{on}i} < 1.5$ and $\delta^*_i > 2.5$): Balanced probability for long-duration activation

**Parameter independence benefits:**

- **Identifiability**: Gene timing parameters are independent of process duration, eliminating scaling symmetry
- **Biological realism**: Process boundaries ($0$ to $T_{\max}$) provide natural temporal reference frame
- **Cross-scale applicability**: Same parameter values work across different experimental timescales
- **Separation of concerns**: Process duration ($T_{\max}$) vs gene-specific timing (onset/duration) vs kinetics (degradation/fold-change)

**Cross-System Biological Interpretation:**

The same $T_{\max} = 5.0$ represents different real-world durations depending on the characteristic splicing rate $\beta$:

- **Immediate-early response** ($\beta = 5 \text{ hr}^{-1}$): Process duration = $5.0/5 = 1$ hour
- **Cell cycle progression** ($\beta = 1 \text{ hr}^{-1}$): Process duration = $5.0/1 = 5$ hours
- **Developmental transition** ($\beta = 0.1 \text{ hr}^{-1}$): Process duration = $5.0/0.1 = 50$ hours

Gene timing parameters maintain consistent biological interpretation across scales.

**Priors for other gene-specific parameters (unchanged from Study 2):**
\begin{align}
    U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2)
\end{align}

**Stick-Breaking Cell Time Construction:**

The cell times $\{t^*_j\}_{j=1}^N$ are constructed using a stick-breaking process with fixed anchor points:

\begin{align}
t^*_1 &= 0 \quad \text{(fixed process start)} \label{eq-anchor-start} \\
t^*_N &= T_{\max} \quad \text{(fixed process end)} \label{eq-anchor-end} \\
\xi_j &\sim \text{Beta}(1, N-j) \quad \text{for } j \in \{2, \ldots, N-1\} \label{eq-stick-breaking-weights} \\
t^*_j &= t^*_{j-1} + \xi_{j-1}(T_{\max} - t^*_{j-1}) \quad \text{for } j \in \{2, \ldots, N-1\} \label{eq-stick-breaking-construction}
\end{align}

This construction automatically ensures:
- **Ordered constraint**: $0 = t^*_1 < t^*_2 < \cdots < t^*_N = T_{\max}$
- **Fixed boundaries**: Process start and end are anchored
- **Efficient sampling**: $O(N)$ complexity with no constraint violations

**Cell-specific capture efficiency (unchanged from Study 2):**
\begin{align}
    \lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
\end{align}

**Dimensionless dynamics with piecewise activation:**

The dimensionless concentrations are computed using the analytical solutions for each phase as derived above, with the appropriate phase determined by comparing $t^*_j$ to the gene-specific activation parameters $t^*_{0,\text{on}i}$ and $\delta^*_i$. The stick-breaking cell times provide the temporal coordinates for evaluating the piecewise analytical solutions.

**Observation model:**
\begin{align}
    u_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}) \\
    s_{ij} &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij})
\end{align}

### Posterior Predictive Check Framework

The posterior predictive checking procedure provides a rigorous mathematical framework for validating the piecewise activation model's ability to recover known parameters from synthetic data. This Bayesian validation approach systematically assesses parameter recovery performance by comparing posterior predictive samples to the original synthetic observations.

#### **Mathematical Formulation of Posterior Predictive Checking**

**Prior Predictive Distribution**

The prior predictive distribution represents the model's predictions before observing any data:

$$p(\tilde{y}) = \int p(\tilde{y} | \theta) p(\theta) d\theta$$

where $\theta$ represents the complete parameter vector including all gene-specific parameters $(\gamma^*_i, R_{\text{on},i}, t^*_{0,\text{on}i}, \delta^*_i, U_{0i})$, process duration parameter $(T_{\max})$, stick-breaking cell times $(t^*_j)$, and cell-specific capture efficiencies $(\lambda_j)$.

#### **Prior Predictive Distribution: Mathematical Foundation**

**Fundamental Definition and Interpretation**

The prior predictive distribution represents the model's predictions about observable data before conditioning on any observations, providing a complete characterization of the model's predictive uncertainty in the absence of data. This marginal distribution integrates over all possible parameter configurations weighted by their prior probabilities.

For the piecewise activation model, this becomes:

\begin{align}
p(\tilde{y}) &= \int p(\tilde{y} | \gamma^*_i, R_{\text{on},i}, t^*_{0,\text{on}i}, \delta^*_i, U_{0i}, T_{\max}, t^*_j, \lambda_j) \times \nonumber \\
&\quad p(\gamma^*_i, R_{\text{on},i}, t^*_{0,\text{on}i}, \delta^*_i, U_{0i}, T_{\max}, t^*_j, \lambda_j) \, d\theta \label{eq-prior-predictive-piecewise}
\end{align}

where the integration spans the complete hierarchical parameter space defined by the model's prior distributions.

**Hierarchical Integration Decomposition**

The prior predictive distribution decomposes according to the model's hierarchical structure:

\begin{align}
p(\tilde{y}) &= \int \int \int \int p(\tilde{y} | T_{\max}, \theta_{\text{gene}}, \theta_{\text{cell}}, \theta_{\text{tech}}) \times \nonumber \\
&\quad p(T_{\max}) \, p(\theta_{\text{gene}}) \, p(\theta_{\text{cell}}) \, p(\theta_{\text{tech}}) \, dT_{\max} \, d\theta_{\text{gene}} \, d\theta_{\text{cell}} \, d\theta_{\text{tech}} \label{eq-hierarchical-integration}
\end{align}

where:

- $\theta_{\text{gene}} = \{\gamma^*_i, R_{\text{on},i}, t^*_{0,\text{on}i}, \delta^*_i, U_{0i}\}_{i=1}^G$ represents gene-specific parameters
- $\theta_{\text{cell}} = \{t^*_j\}_{j=1}^N$ represents stick-breaking cell times
- $\theta_{\text{tech}} = \{\lambda_j\}_{j=1}^N$ represents technical efficiency parameters

This decomposition reflects the model's assumption that gene-specific kinetics, process duration, stick-breaking cell times, and technical factors contribute independently to the prior uncertainty.

**Monte Carlo Approximation**

The prior predictive distribution is computed via Monte Carlo sampling:

\begin{align}
p(\tilde{y}) \approx \frac{1}{S} \sum_{s=1}^S p(\tilde{y} | \theta^{(s)}) \label{eq-mc-prior-predictive}
\end{align}

where $\theta^{(s)} \sim p(\theta)$ are samples from the joint prior distribution.

**Detailed Sampling Procedure:**

1. **Sample process duration**:
   \begin{align}
   {T_{\max}}^{(s)} &\sim \text{Gamma}(5.0, 1.0)
   \end{align}

2. **Sample stick-breaking cell times**:
   \begin{align}
   {\xi_j}^{(s)} &\sim \text{Beta}(1, N-j) \quad \text{for } j \in \{2, \ldots, N-1\} \\
   {t^*_1}^{(s)} &= 0, \quad {t^*_N}^{(s)} = {T_{\max}}^{(s)} \\
   {t^*_j}^{(s)} &= {t^*_{j-1}}^{(s)} + {\xi_{j-1}}^{(s)}({T_{\max}}^{(s)} - {t^*_{j-1}}^{(s)}) \quad \text{for } j \in \{2, \ldots, N-1\}
   \end{align}

3. **Sample gene-specific parameters**:
   \begin{align}
   {\gamma^{*}_i}^{(s)} &\sim \text{LogNormal}(\log(1.0), 0.5^2) \\
   {R_{\text{on},i}}^{(s)} &\sim \text{LogNormal}(\log(2.5), 0.4^2) \\
   {t^*_{0,\text{on}i}}^{(s)} &\sim \text{Normal}(2.5, 1.5^2) \\
   {\delta^*_i}^{(s)} &\sim \text{LogNormal}(0.0, 0.5^2) \\
   {U_{0i}}^{(s)} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2)
   \end{align}

4. **Sample capture efficiencies**:
   \begin{align}
   {\lambda_j}^{(s)} &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)
   \end{align}

5. **Compute latent concentrations**:
   \begin{align}
   {u^{*}_{ij}}^{(s)}, {s^{*}_{ij}}^{(s)} &= f_{\text{piecewise}}({t^*_j}^{(s)}, {\gamma^*_i}^{(s)}, {R_{\text{on},i}}^{(s)}, {t^*_{0,\text{on}i}}^{(s)}, {\delta^*_i}^{(s)})
   \end{align}

6. **Sample observations**:
   \begin{align}
   {u_{ij}}^{(s)} &\sim \text{Poisson}({\lambda_j}^{(s)} \cdot {U_{0i}}^{(s)} \cdot {u^{*}_{ij}}^{(s)}) \\
   {s_{ij}}^{(s)} &\sim \text{Poisson}({\lambda_j}^{(s)} \cdot {U_{0i}}^{(s)} \cdot {s^{*}_{ij}}^{(s)})
   \end{align}

**Prior Predictive Uncertainty Decomposition**

The total prior predictive uncertainty decomposes across the hierarchical parameter structure:

\begin{align}
\text{Var}[\tilde{y}] = \mathbb{E}_\theta[\text{Var}[y|\theta]] + \text{Var}_\theta[\mathbb{E}[y|\theta]] \label{eq-prior-uncertainty-decomp}
\end{align}

where the expectation and variance are taken over the joint prior distribution $p(\theta)$.

**Uncertainty Sources in Prior Predictive:**

The piecewise activation model exhibits multiple sources of prior uncertainty that propagate through the hierarchical structure:

1. **Process duration uncertainty**: Uncertainty in $T_{\max}$ affects the total duration of the biological process, determining the temporal scale for all dynamics

2. **Stick-breaking cell time uncertainty**: Uncertainty in the stick-breaking construction affects the distribution of cells across the process timeline

3. **Gene-specific kinetic uncertainty**: Prior uncertainty in $\gamma^*_i, R_{\text{on},i}$ affects the shape and magnitude of concentration trajectories during each phase

4. **Gene-specific temporal pattern uncertainty**: Prior uncertainty in $t^*_{0,\text{on}i}, \delta^*_i$ affects when activation occurs and how long it lasts in absolute time units

5. **Characteristic scale uncertainty**: Prior uncertainty in $U_{0i}$ affects the absolute magnitude of expression levels for each gene

6. **Technical efficiency uncertainty**: Prior uncertainty in $\lambda_j$ affects the detection efficiency and overall count levels for each cell

7. **Observation noise**: Irreducible Poisson variance in count observations that persists regardless of parameter knowledge

**Mathematical Decomposition:**

For individual observations, the prior predictive variance decomposes as:

\begin{align}
\text{Var}[\tilde{y}_{ij}] = \mathbb{E}[\lambda_j U_{0i} u^*_{ij}(\theta)] + \text{Var}[\lambda_j U_{0i} u^*_{ij}(\theta)] \label{eq-individual-prior-variance}
\end{align}

where the first term represents the expected Poisson variance (observation noise) and the second term represents the variance due to parameter uncertainty propagating through the piecewise dynamics.

**Nonlinear Uncertainty Propagation in Prior Predictive:**

Parameter uncertainty propagates nonlinearly through the piecewise analytical solutions under the prior:

- **Phase assignment uncertainty**: Prior uncertainty in temporal parameters creates uncertainty about which phase each cell-gene pair occupies, leading to mixture-like behavior in the prior predictive distribution

- **Exponential amplification**: The exponential terms in analytical solutions amplify prior parameter uncertainty, particularly for genes with large characteristic scales or cells at extreme time points

- **Process duration interactions**: Uncertainty in $T_{\max}$ affects the temporal boundaries but does not automatically scale gene parameters, creating asymmetric uncertainty propagation

- **Special case transitions**: Prior probability mass near $\gamma^*_i = 1$ creates discontinuous changes in the analytical solution form, contributing additional uncertainty

**Relationship to Posterior Predictive**

**Bayesian Learning Interpretation:**

The posterior predictive distribution represents the prior predictive distribution updated by observed data:

\begin{align}
p(\tilde{y} | y_{obs}) = \int p(\tilde{y} | \theta) p(\theta | y_{obs}) d\theta \label{eq-posterior-predictive-relation}
\end{align}

where $p(\theta | y_{obs}) \propto p(y_{obs} | \theta) p(\theta)$ incorporates the likelihood of observed data through Bayes' theorem.

**Uncertainty Reduction:**

Bayesian learning systematically reduces predictive uncertainty:

\begin{align}
\text{Var}[\tilde{y} | y_{obs}] \leq \text{Var}[\tilde{y}] \label{eq-uncertainty-reduction}
\end{align}

with equality only when the observed data provides no information about the parameters (i.e., when the likelihood is flat).

**Information Content Quantification:**

The reduction in predictive uncertainty quantifies the information content of the observed data:

\begin{align}
\text{Information} = \text{Var}[\tilde{y}] - \text{Var}[\tilde{y} | y_{obs}] \label{eq-information-content}
\end{align}

This quantity measures how much the data constrains the model's predictions about future observations.

**Prior Predictive Validation Applications**

**Model Specification Validation:**

Prior predictive checks validate whether the model can generate data with realistic characteristics:

1. **Count distribution realism**: Do prior predictive counts match expected single-cell RNA-seq distributional properties (mean-variance relationships, sparsity patterns, dynamic range)?

2. **Temporal coordination**: Does the hierarchical time structure produce biologically plausible cell orderings and temporal relationships?

3. **Expression magnitude realism**: Do the characteristic scales $U_{0i}$ and capture efficiencies $\lambda_j$ combine to produce realistic expression levels?

4. **Kinetic parameter coverage**: Does the prior cover the range of biologically plausible kinetic behaviors without generating unrealistic dynamics?

**Prior Sensitivity Analysis:**

Compare prior predictive distributions under different hyperparameter choices:

\begin{align}
p(\tilde{y} | \alpha_1) \text{ vs. } p(\tilde{y} | \alpha_2) \label{eq-prior-sensitivity}
\end{align}

where $\alpha_1, \alpha_2$ represent different hyperparameter configurations. This analysis identifies which hyperparameters most strongly influence prior predictions.

**Computational Validation:**

Prior predictive sampling validates computational implementation:

1. **Convergence assessment**: Do prior predictive samples converge to stable distributions as the number of samples increases?

2. **Numerical stability**: Are analytical solutions numerically stable across the full range of prior parameter values?

3. **Phase assignment consistency**: Do temporal parameters correctly determine phase assignments across all prior samples?

4. **Parameter constraint satisfaction**: Do all prior samples satisfy model constraints (e.g., positive concentrations, valid phase boundaries)?

**Posterior Predictive Distribution**

After observing synthetic data $y_{obs}$, the posterior predictive distribution incorporates learned parameter constraints:

$$p(\tilde{y} | y_{obs}) = \int p(\tilde{y} | \theta) p(\theta | y_{obs}) d\theta$$

This distribution quantifies the model's uncertainty about future observations given what it has learned from the synthetic data.

**Hierarchical Uncertainty Decomposition**

The piecewise activation model exhibits a complex uncertainty hierarchy that propagates from parameters through latent concentrations to final observations:

1. **Parameter uncertainty**: $\text{Var}[\theta | y_{obs}]$ from the posterior distribution over all model parameters
2. **Temporal uncertainty**: Uncertainty in latent time coordinates $t^*_j$ and their hierarchical structure
3. **Kinetic uncertainty**: Uncertainty in gene-specific kinetic parameters $\gamma^*_i$ and fold-changes $R_{\text{on},i}$
4. **Concentration uncertainty**: Uncertainty in predicted latent concentrations $u^*_{ij}(\theta), s^*_{ij}(\theta)$ arising from parameter uncertainty
5. **Observation uncertainty**: Poisson noise in final count observations

The total predictive uncertainty decomposes as:

$$\text{Var}[\tilde{y} | y_{obs}] = \mathbb{E}_\theta[\text{Var}[y|\theta]] + \text{Var}_\theta[\mathbb{E}[y|\theta]]$$

where the first term represents irreducible observation noise (Poisson variance) and the second term represents reducible uncertainty due to parameter estimation.

#### **Model-Specific Implementation for Piecewise Activation**

**Complete Parameter Space**

The piecewise activation model's parameter space $\theta$ includes:

- **Non-temporal gene parameters**: $\gamma^*_i \sim \text{LogNormal}(\log(1.0), 0.5^2)$, $R_{\text{on},i} \sim \text{LogNormal}(\log(2.5), 0.4^2)$
- **Absolute temporal gene parameters**: $t^*_{0,\text{on}i} \sim \text{Normal}(2.5, 1.5^2)$, $\delta^*_i \sim \text{LogNormal}(0.0, 0.5^2)$
- **Characteristic scales**: $U_{0i} \sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2)$
- **Process duration**: $T_{\max} \sim \text{Gamma}(5.0, 1.0)$
- **Stick-breaking cell times**: $t^*_1 = 0$, $t^*_N = T_{\max}$, $\xi_j \sim \text{Beta}(1, N-j)$, $t^*_j = t^*_{j-1} + \xi_{j-1}(T_{\max} - t^*_{j-1})$
- **Capture efficiencies**: $\lambda_j \sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2)$

**Dimensionless Dynamics with Piecewise Activation**

The latent concentrations are computed using analytical solutions that depend on which phase each cell-gene pair occupies:

$$u^*_{ij}(\theta), s^*_{ij}(\theta) = f_{\text{piecewise}}(t^*_j, \gamma^*_i, R_{\text{on},i}, t^*_{0,\text{on}i}, \delta^*_i)$$

where $f_{\text{piecewise}}$ represents the appropriate analytical solution (Phase 1, 2, or 3) determined by comparing $t^*_j$ to the gene-specific activation timing parameters.

**Poisson Observation Model with Scaling**

The final observations follow Poisson distributions with rates determined by the latent concentrations:

\begin{align}
u_{ij} | \theta &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}(\theta)) \\
s_{ij} | \theta &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij}(\theta))
\end{align}

This scaling structure ensures that parameter uncertainty propagates through the characteristic scales $U_{0i}$ and capture efficiencies $\lambda_j$ to the final count observations.

#### **Validation Procedure: Mathematical Description**

The parameter recovery validation procedure systematically compares prior and posterior predictive distributions to assess the model's ability to learn from data.

**Step 1: Synthetic Data Generation from Prior Predictive**

Generate synthetic data with known "true" parameters by sampling from the prior predictive distribution as described in equations \eqref{eq-prior-predictive-piecewise}-\eqref{eq-mc-prior-predictive}:

1. **Sample true parameters**: $\theta_{true} \sim p(\theta)$ following the hierarchical sampling procedure
2. **Compute latent concentrations**: $u^*_{ij,true}, s^*_{ij,true} = f_{\text{piecewise}}(t^*_{j,true}, \theta_{true})$ using the piecewise analytical solutions
3. **Generate synthetic observations**: $y_{obs} = \{u_{ij}, s_{ij}\} \sim p(y | \theta_{true})$ from the Poisson observation model

This step creates a controlled validation scenario where the "true" parameter values are known by construction, enabling direct assessment of parameter recovery performance.

**Step 2: Posterior Inference**

Fit the model to synthetic data to obtain the posterior distribution:

$$p(\theta | y_{obs}) \propto p(y_{obs} | \theta) p(\theta)$$

This step uses MCMC or variational inference to approximate the posterior distribution over all model parameters.

**Step 3: Posterior Sampling**

Extract $S$ posterior samples from the fitted model:

$$\{\theta^{(s)}\}_{s=1}^S \sim p(\theta | y_{obs})$$

Each sample $\theta^{(s)}$ represents a complete parameter configuration consistent with the observed synthetic data.

**Step 4: Posterior Predictive Sampling**

For each posterior sample $\theta^{(s)}$, generate a corresponding posterior predictive sample:

$$\tilde{y}^{(s)} \sim p(y | \theta^{(s)})$$

**Mathematical Prohibition Against Parameter Averaging**: 

**Correct Sampling**: Each $\tilde{y}^{(s)}$ must be generated using the complete parameter vector $\theta^{(s)}$:

1. Compute phase assignments for each cell-gene pair using ${{t^{\ast}_{j}}}^{(s)}$, ${{t^{\ast}_{0,\text{on}i}}}^{(s)}$, ${{\delta^{\ast}_i}}^{(s)}$
2. Evaluate analytical solutions: ${{u^*_{ij}}}^{(s)}, {{s^*_{ij}}}^{(s)} = f_{\text{piecewise}}({{t^*_{j}}}^{(s)}, {{\gamma^*_i}}^{(s)}, {{R_{\text{on},i}}}^{(s)}, {{t^*_{0,\text{on}i}}}^{(s)}, {{\delta^*_i}}^{(s)})$
3. Sample observations: 

\begin{align}
{{u_{ij}}}^{(s)} &\sim \text{Poisson}({{\lambda_j}}^{(s)} \cdot {{U_{0i}}}^{(s)} \cdot {{u^*_{ij}}}^{(s)}) \\
{{s_{ij}}}^{(s)} &\sim \text{Poisson}({{\lambda_j}}^{(s)} \cdot {{U_{0i}}}^{(s)} \cdot {{s^*_{ij}}}^{(s)})
\end{align}

The posterior predictive distribution cannot be computed using averaged parameters such as

\begin{align}
\bar{\theta} = \frac{1}{S}\sum_{s=1}^S {\theta}^{(s)}
\end{align}

Using $\bar{\theta}$ would violate the fundamental definition of posterior predictive distributions and fails to capture parameter uncertainty propagation through the nonlinear dynamics.

**Step 5: Validation Assessment**

Compare posterior predictive samples $\{\tilde{y}^{(s)}\}_{s=1}^S$ to the original synthetic data $y_{obs}$ using multiple validation metrics.

#### **Uncertainty Propagation Through Piecewise Dynamics**

**Parameter Uncertainty Sources**

The piecewise activation model exhibits multiple sources of parameter uncertainty:

1. **Kinetic parameter uncertainty**: Posterior distributions over $\gamma^*_i$ and $R_{\text{on},i}$ affect the shape and magnitude of concentration trajectories
2. **Temporal parameter uncertainty**: Uncertainty in $t^*_{0,\text{on}i}$ and $\delta^*_i$ affects when activation occurs and how long it lasts
3. **Process duration uncertainty**: Uncertainty in $T_{\max}$ affects the total process duration and temporal boundaries
4. **Cell-specific uncertainty**: Uncertainty in individual $t^*_j$ and $\lambda_j$ affects cell-specific predictions
5. **Scale uncertainty**: Uncertainty in $U_{0i}$ affects the absolute magnitude of predicted counts

**Nonlinear Uncertainty Propagation**

Parameter uncertainty propagates nonlinearly through the piecewise analytical solutions:

- **Phase transitions**: Small changes in temporal parameters can cause cells to switch between phases, leading to discontinuous changes in predicted concentrations
- **Exponential sensitivity**: The exponential terms in analytical solutions amplify parameter uncertainty, particularly for large time values
- **Interaction effects**: Uncertainty in $\gamma^*_i$ interacts with uncertainty in temporal parameters through the $\xi$ helper variables
- **Special case sensitivity**: Near $\gamma^*_i = 1$, the transition between solution forms creates additional uncertainty

**Total Predictive Uncertainty Decomposition**

For the piecewise activation model, the total predictive uncertainty can be decomposed as:

\begin{align}
\text{Var}[\tilde{y}_{ij} | y_{obs}] &= \mathbb{E}_\theta[\lambda_j U_{0i} u^*_{ij}(\theta)] + \text{Var}_\theta[\lambda_j U_{0i} u^*_{ij}(\theta)] \\
&= \text{Poisson variance} + \text{Parameter uncertainty}
\end{align}

The parameter uncertainty term captures the complex propagation of uncertainty through the hierarchical parameter structure and piecewise dynamics.

#### **Validation Metrics for Posterior Predictive Checking**

**Parameter Recovery Assessment**

Compare true parameters $\theta_{true}$ to posterior samples $\{\theta^{(s)}\}_{s=1}^S$:

1. **Coverage probability**: Fraction of true parameters falling within posterior credible intervals
   $$\text{Coverage}(\alpha) = \frac{1}{|\Theta|} \sum_{\theta_k \in \Theta} \mathbb{I}[\theta_{k,true} \in \text{CI}_\alpha(\theta_k | y_{obs})]$$
   where $\text{CI}_\alpha$ is the $\alpha$-level credible interval.

2. **Posterior mean bias**: Systematic deviation of posterior means from true values
   $$\text{Bias}(\theta_k) = \mathbb{E}[\theta_k | y_{obs}] - \theta_{k,true}$$

3. **Posterior standard deviation**: Measure of parameter uncertainty
   $$\text{SD}(\theta_k) = \sqrt{\text{Var}[\theta_k | y_{obs}]}$$

**Predictive Accuracy Assessment**

Compare observed synthetic data $y_{obs}$ to posterior predictive samples $\{\tilde{y}^{(s)}\}_{s=1}^S$:

1. **Mean Absolute Error (MAE)**: Average absolute deviation between observations and posterior predictive means
   $$\text{MAE} = \frac{1}{GN} \sum_{i=1}^G \sum_{j=1}^N |y_{ij,obs} - \mathbb{E}[\tilde{y}_{ij} | y_{obs}]|$$

2. **Root Mean Square Error (RMSE)**: Penalizes large deviations more heavily
   $$\text{RMSE} = \sqrt{\frac{1}{GN} \sum_{i=1}^G \sum_{j=1}^N (y_{ij,obs} - \mathbb{E}[\tilde{y}_{ij} | y_{obs}])^2}$$

3. **Posterior predictive p-values**: Probability that replicated data would be more extreme than observed data
   $$p_{pp} = P(T(\tilde{y}) \geq T(y_{obs}) | y_{obs})$$
   where $T(\cdot)$ is a test statistic (e.g., mean, variance, skewness).

#### **Computational Considerations for Piecewise Models**

**Analytical Solution Advantages**

The piecewise activation model's analytical solutions provide computational benefits for posterior predictive checking:

1. **Fast likelihood evaluation**: No numerical integration required for each posterior sample
2. **Exact uncertainty propagation**: Analytical derivatives enable precise uncertainty quantification
3. **Efficient validation**: Rapid generation of large numbers of posterior predictive samples
4. **Numerical stability**: Closed-form solutions avoid accumulation of numerical errors

**Phase Assignment Efficiency**

For each posterior sample $\theta^{(s)}$, phase assignments can be computed efficiently:

1. **Vectorized comparisons**: Determine phases for all cell-gene pairs simultaneously
2. **Cached computations**: Reuse phase-specific analytical solutions across similar parameter values
3. **Parallel processing**: Generate multiple posterior predictive samples in parallel

**Memory Management**

Large posterior predictive sample sets require careful memory management:

1. **Streaming generation**: Generate and process samples sequentially to avoid memory overflow
2. **Selective storage**: Store only essential summary statistics rather than full sample arrays
3. **Compressed representations**: Use efficient data structures for sparse count matrices

#### **Biological Interpretation of Validation Results**

**Successful Parameter Recovery Indicators**

1. **High coverage probabilities** (>90%) indicate the model correctly quantifies parameter uncertainty
2. **Low posterior bias** indicates the model can accurately estimate true parameter values
3. **Appropriate posterior uncertainty** balances precision with realistic uncertainty quantification

**Predictive Accuracy Indicators**

1. **Low MAE/RMSE** indicates accurate point predictions
2. **Posterior predictive p-values near 0.5** indicate good model fit without over- or under-fitting
3. **Consistent pattern classification** indicates the model captures essential temporal dynamics

**Failure Mode Identification**

1. **Poor coverage** may indicate model misspecification or inadequate prior specification
2. **High bias** may indicate identifiability issues or optimization problems
3. **Poor predictive accuracy** may indicate missing biological mechanisms or inappropriate noise models

### Properties of the Process Duration with Stick-Breaking Framework

#### **Resolved Identifiability Issues**

- **Eliminates scaling symmetry**: Fixed anchor points ($t^*_1 = 0$, $t^*_N = T_{\max}$) break scaling symmetry that plagued hierarchical scaling approaches
- **Parameter identifiability**: Gene timing parameters are independent of process duration, ensuring unique parameter estimates
- **Mathematical rigor**: Formal proof that likelihood is not invariant under parameter scaling
- **Computational stability**: Eliminates non-identifiable parameter combinations that cause inference failures

#### **Resolved Dimensional Analysis Issues**

- **Eliminates parameter redundancy**: No ambiguity between $U_{0i}$ and $\alpha^*_{\text{off}i}$ since $\alpha^*_{\text{off}i} = 1.0$ (fixed)
- **Clear dimensional structure**: $U_{0i}$ unambiguously represents off-state concentration scale
- **Proper parameter hierarchy**: Each inferred parameter has a unique biological role
- **No separate inference of initial conditions**: $u^*_{0i}, s^*_{0i}$ fixed to steady-state values
- **Biological realism**: Steady-state initial conditions are more plausible than arbitrary values

#### **Enhanced Temporal Modeling**

- **Process boundaries**: Clear start ($t^* = 0$) and end ($t^* = T_{\max}$) of biological process
- **Pre-activation scenarios**: Models genes already activated when process begins
- **Flexible onset timing**: Normal prior allows negative onset times naturally
- **Automatic ordering**: Stick-breaking ensures proper temporal ordering without constraints
- **Cross-scale applicability**: Same framework works across different experimental timescales

#### **Rich Expression Pattern Representation**

The framework captures three core expression patterns that encompass the full range of biologically relevant temporal dynamics:

- **Pre-activation genes**: Already activated before observation, showing decay-only dynamics from activated steady-state
- **Transient genes**: Complete activation-decay cycles within observation window, exhibiting pulse-like dynamics
- **Sustained genes**: Early activation with long duration, showing net increase over observation period

**Pattern coverage**: These three patterns effectively capture the essential temporal dynamics while eliminating redundant classifications. The absolute temporal parameterization with process boundaries ensures consistent pattern identification across different experimental timescales.

#### **Analytical Tractability**

- **Fast likelihood evaluation**: All phases solved analytically
- **Efficient parameter recovery validation**: No numerical integration required
- **Clear mathematical structure**: Each phase has explicit closed-form solution

#### **Biological Interpretability**

- **Dimensionless parameters**: Universal interpretation across experimental conditions
- **Process boundaries**: Natural temporal reference frame from start to completion
- **Temporal progression**: Intuitive progress metric ($t^*_j / T_{\max}$) for cellular advancement
- **Gene-specific dynamics**: Each gene can follow distinct activation pattern independent of process duration

### Parameter Recovery Validation Strategy

This study will validate the process duration with stick-breaking model's ability to:

1. **Recover identifiable parameters**: $\gamma^*_i$, $R_{\text{on},i}$, $t^*_{0,\text{on}i}$, $\delta^*_i$, $T_{\max}$
2. **Demonstrate scaling symmetry elimination**: Verify that different $T_{\max}$ values produce distinguishable likelihoods
3. **Validate anchor point constraints**: Confirm that $t^*_1 = 0$ and $t^*_N = T_{\max}$ are properly enforced
4. **Assess stick-breaking cell time inference**: Recover proper temporal ordering and distribution
5. **Handle realistic noise levels**: Maintain accuracy with Poisson observation noise
6. **Scale efficiently**: Demonstrate computational advantages of analytical solutions
7. **Validate fold-change interpretation**: Ensure $R_{\text{on},i}$ estimates match true activation strength
8. **Assess dimensional consistency**: Verify elimination of parameter redundancy through fixed $\alpha^*_{\text{off}i} = 1.0$
9. **Validate parameter independence**: Ensure gene timing parameters are independent of process duration
10. **Assess parameter separation**: Verify clean separation between kinetic ($\gamma^*_i$, $R_{\text{on},i}$) and temporal ($t^*_{0,\text{on}i}$, $\delta^*_i$) parameter inference
11. **Validate process boundary framework**: Confirm that absolute temporal parameters enable consistent pattern classification across different experimental timescales
12. **Cross-scale validation**: Test parameter recovery across different process durations to verify identifiability

### Parameter Recovery Validation Implementation

This validation workflow demonstrates the key capabilities of the process duration with stick-breaking model:

- **Parameter identifiability**: Eliminates scaling symmetry through fixed anchor points and independent gene timing
- **Analytical tractability**: Fast likelihood evaluation enables efficient parameter recovery validation
- **Rich parameter space**: Includes fold-change parameters, absolute temporal parameters, and process duration
- **Pre-activation modeling**: Supports negative onset times for genes already activated before process start
- **Dimensional consistency**: Eliminates parameter redundancy through fixed reference state parameterization
- **Biological interpretability**: All parameters have clear biological meaning with process boundary interpretation
- **Comprehensive prior predictive framework**: Mathematical foundation for validating model specification through prior predictive checking as detailed in equations \eqref{eq-prior-predictive-piecewise}-\eqref{eq-information-content}, ensuring the model can generate realistic data patterns before observing any data
- **Process boundary parameterization**: Enables interpretable parameter values and consistent pattern classification across different experimental timescales through natural temporal reference frame

The complete validation scripts referenced in the introduction (`prior-predictive-check.py` and `posterior-predictive-check.py`) provide comprehensive parameter recovery validation including visualization and statistical assessment of recovery performance. The prior predictive checking framework validates model specification and prior adequacy, while the posterior predictive checking framework assesses parameter recovery and predictive accuracy.

## Dimensionless Analytical Dynamics with Branching Trajectories and Piecewise Activation {#sec-dimless-branching-piecewise}

This validation study extends the stick-breaking temporal coordinate model to accommodate **branching developmental trajectories** through a mathematically rigorous mixture model framework. The key innovation is a **branch mixture extension** that maintains all analytical tractability and identifiability properties while enabling modeling of cell fate decisions, lineage bifurcations, and heterogeneous developmental pathways within a unified probabilistic framework.

### Model Description

The branching mixture model extends the process duration with stick-breaking framework by introducing **discrete branch assignments** that partition cells into distinct developmental trajectories. Each branch maintains its own temporal coordinate system and gene expression parameters while sharing the same underlying analytical solutions and dimensional consistency principles. This approach enables modeling of complex developmental processes where cells follow different trajectories with branch-specific timing and expression patterns.

The model generates count data for unspliced ($u$) and spliced ($s$) RNA molecules per cell, with dynamics governed by **branch-specific piecewise analytical solutions** and observation model that scales back to dimensional counts through characteristic scales and effective capture efficiency. Each cell is assigned to exactly one branch, and all parameters are conditionally independent given branch assignments.

### Probabilistic Graphical Model

The probabilistic graphical model represents the branching extension with discrete branch assignments, branch-specific temporal coordinates, and branch-specific gene expression parameters. The model maintains the same dimensional consistency and analytical tractability as the single-branch framework while enabling rich heterogeneity across developmental trajectories.

```{python}
#| label: fig-branching-model-pgm
#| code-fold: true
#| fig-cap: Probabilistic graphical model for dimensionless analytical dynamics with branching trajectories and piecewise activation. Branch assignments partition cells into distinct developmental pathways with branch-specific temporal coordinates and gene expression parameters.

import daft
import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 14
plt.rcParams["text.usetex"] = True
plt.rcParams["text.latex.preamble"] = r"\usepackage{amsmath}"

pgm = daft.PGM(line_width=1.2)

# Branch structure hyperparameters
pgm.add_node("alpha_K", r"$\alpha_K$", 0.5, 7, fixed=True)
pgm.add_node("alpha_pi", r"$\alpha_\pi$", 1.5, 7, fixed=True)

# Gene parameter hyperparameters (shared across branches)
pgm.add_node("mu_gamma", r"$\mu_{\gamma^*}$", 3, 7, fixed=True)
pgm.add_node("sigma_gamma", r"$\sigma_{\gamma^*}^2$", 3.5, 7, fixed=True)
pgm.add_node("mu_U0", r"$\mu_{U_0}$", 4.5, 7, fixed=True)
pgm.add_node("sigma_U0", r"$\sigma_{U_0}^2$", 5, 7, fixed=True)

# Branch-specific hyperparameters
pgm.add_node("alpha_T", r"$\alpha_T$", 6, 7, fixed=True)
pgm.add_node("beta_T", r"$\beta_T$", 6.5, 7, fixed=True)
pgm.add_node("mu_on_k", r"$\mu_{on,k}$", 7.5, 7, fixed=True)
pgm.add_node("sigma_on", r"$\sigma_{on}^2$", 8, 7, fixed=True)
pgm.add_node("mu_delta_k", r"$\mu_{\delta,k}$", 8.5, 7, fixed=True)
pgm.add_node("sigma_delta", r"$\sigma_{\delta}^2$", 9, 7, fixed=True)
pgm.add_node("mu_R_k", r"$\mu_{R,k}$", 9.5, 7, fixed=True)
pgm.add_node("sigma_R", r"$\sigma_R^2$", 10, 7, fixed=True)

# Branch structure
pgm.add_node("K", r"$K$", 1, 6)
pgm.add_node("pi", r"$\boldsymbol{\pi}$", 2, 6)

# Branch-specific parameters
pgm.add_node("T_max_k", r"$T_{\max,k}$", 6.25, 6)

# Gene-specific parameters (shared)
pgm.add_node("gamma_star_i", r"$\gamma^*_i$", 3.25, 5.5)
pgm.add_node("U_0i", r"$U_{0i}$", 4.5, 5.5)

# Branch-gene-specific parameters
pgm.add_node("t_on_ik", r"${t^*_{on}}_{ik}$", 7.5, 5.5)
pgm.add_node("delta_ik", r"$\delta^*_{ik}$", 8.5, 5.5)
pgm.add_node("R_on_ik", r"$R_{on,ik}$", 9.5, 5.5)

# Cell assignments and parameters
pgm.add_node("Z_j", r"$Z_j$", 2, 5)
pgm.add_node("t_star_j", r"${t^*}_j$", 6.25, 5)
pgm.add_node("lambda_j", r"$\lambda_j$", 5, 4.5)

# Latent concentrations
pgm.add_node("u_star_ij", r"$u^*_{ij}$", 3.25, 4, scale=1.0, shape="rectangle")
pgm.add_node("s_star_ij", r"$s^*_{ij}$", 4.5, 4, scale=1.0, shape="rectangle")

# Observed counts
pgm.add_node("u_obs_ij", r"$u_{ij}$", 3.25, 3, scale=1.0, observed=True)
pgm.add_node("s_obs_ij", r"$s_{ij}$", 4.5, 3, scale=1.0, observed=True)

# edges
edge_params = {"head_length": 0.25, "head_width": 0.2, "lw": 0.6}

# Branch structure edges
pgm.add_edge("alpha_K", "K", plot_params=edge_params)
pgm.add_edge("alpha_pi", "pi", plot_params=edge_params)
pgm.add_edge("K", "pi", plot_params=edge_params)
pgm.add_edge("pi", "Z_j", plot_params=edge_params)

# Branch-specific parameter edges
pgm.add_edge("alpha_T", "T_max_k", plot_params=edge_params)
pgm.add_edge("beta_T", "T_max_k", plot_params=edge_params)
pgm.add_edge("mu_on_k", "t_on_ik", plot_params=edge_params)
pgm.add_edge("sigma_on", "t_on_ik", plot_params=edge_params)
pgm.add_edge("mu_delta_k", "delta_ik", plot_params=edge_params)
pgm.add_edge("sigma_delta", "delta_ik", plot_params=edge_params)
pgm.add_edge("mu_R_k", "R_on_ik", plot_params=edge_params)
pgm.add_edge("sigma_R", "R_on_ik", plot_params=edge_params)

# Gene parameter edges
pgm.add_edge("mu_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("sigma_gamma", "gamma_star_i", plot_params=edge_params)
pgm.add_edge("mu_U0", "U_0i", plot_params=edge_params)
pgm.add_edge("sigma_U0", "U_0i", plot_params=edge_params)

# Temporal coordinate edges
pgm.add_edge("Z_j", "t_star_j", plot_params=edge_params)
pgm.add_edge("T_max_k", "t_star_j", plot_params=edge_params)

# Dynamics edges
pgm.add_edge("gamma_star_i", "u_star_ij", plot_params=edge_params)
pgm.add_edge("gamma_star_i", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_on_ik", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_on_ik", "s_star_ij", plot_params=edge_params)
pgm.add_edge("delta_ik", "u_star_ij", plot_params=edge_params)
pgm.add_edge("delta_ik", "s_star_ij", plot_params=edge_params)
pgm.add_edge("R_on_ik", "u_star_ij", plot_params=edge_params)
pgm.add_edge("R_on_ik", "s_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "u_star_ij", plot_params=edge_params)
pgm.add_edge("t_star_j", "s_star_ij", plot_params=edge_params)

# Observation edges
pgm.add_edge("u_star_ij", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("s_star_ij", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("U_0i", "s_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "u_obs_ij", plot_params=edge_params)
pgm.add_edge("lambda_j", "s_obs_ij", plot_params=edge_params)

# plates
pgm.add_plate([0.75, 6.25, 1.75, 1.25], label=r"$k \in \{1, \ldots, K\}$", shift=-0.1, fontsize=10)
pgm.add_plate([2.75, 4.75, 7.25, 1.25], label=r"$i \in \{1, \ldots, G\}$", shift=-0.1, fontsize=10)
pgm.add_plate([1.5, 2.5, 4, 3], label=r"$j \in \{1, \ldots, N\}$", shift=-0.1, fontsize=10)

pgm.render()
```

### Mathematical Description

The branching mixture model extends the stick-breaking framework with **discrete branch assignments** and **branch-specific parameters**. The model maintains analytical tractability and identifiability while enabling rich heterogeneity across developmental trajectories.

**Hyperpriors for branch structure:**
\begin{align}
\alpha_K &\sim \text{Gamma}(2.0, 1.0) \label{eq-alpha-K-hyperprior} \\
\alpha_\pi &\sim \text{Gamma}(1.0, 1.0) \label{eq-alpha-pi-hyperprior}
\end{align}

**Branch structure:**
\begin{align}
K &\sim \text{Poisson}(\alpha_K) + 1 \label{eq-branch-count} \\
\boldsymbol{\pi} &\sim \text{Dirichlet}\left(\frac{\alpha_\pi}{K} \mathbf{1}_K\right) \label{eq-branch-probabilities} \\
Z_j &\sim \text{Categorical}(\boldsymbol{\pi}) \quad \text{for } j \in \{1, \ldots, N\} \label{eq-branch-assignments}
\end{align}

where $K$ is the number of branches, $\boldsymbol{\pi} = (\pi_1, \ldots, \pi_K)$ are branch probabilities, and $Z_j \in \{1, \ldots, K\}$ is the branch assignment for cell $j$.

**Hyperpriors for temporal parameters:**
\begin{align}
\alpha_T &\sim \text{Gamma}(5.0, 1.0) \label{eq-alpha-T-hyperprior} \\
\beta_T &\sim \text{Gamma}(1.0, 1.0) \label{eq-beta-T-hyperprior}
\end{align}

**Branch-specific temporal coordinates:**
\begin{align}
T_{\max,k} &\sim \text{Gamma}(\alpha_T, \beta_T) \quad \text{for } k \in \{1, \ldots, K\} \label{eq-branch-duration}
\end{align}

**Rigorous stick-breaking specification within branches:**

For each branch $k \in \{1, \ldots, K\}$, let $\mathcal{C}_k = \{j : Z_j = k\}$ denote the set of cells assigned to branch $k$, and let $\mathcal{N}_k = |\mathcal{C}_k|$ be the number of cells in branch $k$. Order the cells within branch $k$ as $j_{k,1}, j_{k,2}, \ldots, j_{k,\mathcal{N}_k}$ (ordering can be arbitrary). The stick-breaking process for branch $k$ is defined as:

\begin{align}
V_{k,\ell} &\sim \text{Beta}(1, \mathcal{N}_k - \ell) \quad \text{for } \ell \in \{1, \ldots, \mathcal{N}_k - 1\} \label{eq-branch-beta-variables-rigorous} \\
\tilde{t}_{k,1} &= 0 \label{eq-branch-first-time} \\
\tilde{t}_{k,\ell} &= \tilde{t}_{k,\ell-1} + V_{k,\ell-1} \prod_{m=1}^{\ell-2} (1 - V_{k,m}) \quad \text{for } \ell \in \{2, \ldots, \mathcal{N}_k\} \label{eq-branch-stick-construction-rigorous} \\
\tilde{t}_{k,\mathcal{N}_k} &= 1 \quad \text{(normalization constraint)} \label{eq-branch-last-time} \\
{t^*}_{j_{k,\ell}} &= T_{\max,k} \times \tilde{t}_{k,\ell} \quad \text{for } \ell \in \{1, \ldots, \mathcal{N}_k\} \label{eq-branch-time-scaling-rigorous}
\end{align}

This construction ensures that for each branch $k$:
\begin{align}
0 = {t^*}_{j_{k,1}} < {t^*}_{j_{k,2}} < \cdots < {t^*}_{j_{k,\mathcal{N}_k}} = T_{\max,k} \label{eq-branch-ordering}
\end{align}

**Hyperpriors for shared gene parameters:**
\begin{align}
\mu_{\gamma^*} &\sim \text{Normal}(0.0, 1.0^2) \label{eq-mu-gamma-hyperprior} \\
\sigma_{\gamma^*}^2 &\sim \text{InverseGamma}(2.0, 0.5^2) \label{eq-sigma-gamma-hyperprior} \\
\mu_{U_0} &\sim \text{Normal}(4.0, 1.0^2) \label{eq-mu-U0-hyperprior} \\
\sigma_{U_0}^2 &\sim \text{InverseGamma}(2.0, 0.5^2) \label{eq-sigma-U0-hyperprior} \\
\mu_{\lambda} &\sim \text{Normal}(0.0, 1.0^2) \label{eq-mu-lambda-hyperprior} \\
\sigma_{\lambda}^2 &\sim \text{InverseGamma}(2.0, 0.5^2) \label{eq-sigma-lambda-hyperprior}
\end{align}

**Gene-specific parameters (shared across branches):**
\begin{align}
\gamma^*_i &\sim \text{LogNormal}(\mu_{\gamma^*}, \sigma_{\gamma^*}^2) \quad \text{for } i \in \{1, \ldots, G\} \label{eq-shared-gamma} \\
U_{0i} &\sim \text{LogNormal}(\mu_{U_0}, \sigma_{U_0}^2) \quad \text{for } i \in \{1, \ldots, G\} \label{eq-shared-U0}
\end{align}

**Hyperpriors for branch-specific gene parameters:**
\begin{align}
\mu_{on,k} &\sim \text{Normal}(2.5, 1.5^2) \quad \text{for } k \in \{1, \ldots, K\} \label{eq-mu-on-k-hyperprior} \\
\sigma_{on}^2 &\sim \text{InverseGamma}(2.0, 1.0^2) \label{eq-sigma-on-hyperprior} \\
\mu_{\delta,k} &\sim \text{Normal}(0.0, 0.5^2) \quad \text{for } k \in \{1, \ldots, K\} \label{eq-mu-delta-k-hyperprior} \\
\sigma_{\delta}^2 &\sim \text{InverseGamma}(2.0, 0.25^2) \label{eq-sigma-delta-hyperprior} \\
\mu_{R,k} &\sim \text{Normal}(\log(2.5), 0.4^2) \quad \text{for } k \in \{1, \ldots, K\} \label{eq-mu-R-k-hyperprior} \\
\sigma_R^2 &\sim \text{InverseGamma}(2.0, 0.2^2) \label{eq-sigma-R-hyperprior}
\end{align}

**Branch-gene-specific parameters:**
\begin{align}
{t^*_{on}}_{ik} &\sim \text{Normal}(\mu_{on,k}, \sigma_{on}^2) \quad \text{for } i \in \{1, \ldots, G\}, k \in \{1, \ldots, K\} \label{eq-branch-onset} \\
\delta^*_{ik} &\sim \text{LogNormal}(\mu_{\delta,k}, \sigma_{\delta}^2) \quad \text{for } i \in \{1, \ldots, G\}, k \in \{1, \ldots, K\} \label{eq-branch-duration-gene} \\
R_{on,ik} &\sim \text{LogNormal}(\mu_{R,k}, \sigma_R^2) \quad \text{for } i \in \{1, \ldots, G\}, k \in \{1, \ldots, K\} \label{eq-branch-fold-change}
\end{align}

**Cell-specific capture efficiency:**
\begin{align}
\lambda_j &\sim \text{LogNormal}(\mu_{\lambda}, \sigma_{\lambda}^2) \quad \text{for } j \in \{1, \ldots, N\} \label{eq-branch-lambda}
\end{align}

**Branch-specific piecewise analytical solutions:**

For cell $j$ assigned to branch $k$ (i.e., $Z_j = k$), the dimensionless transcription rate for gene $i$ is:

\begin{align}
\alpha^*_{ik}(t^*) &:= \begin{cases}
1.0 & \text{if } t^* < {t^*_{on}}_{ik} \\
R_{on,ik} & \text{if } {t^*_{on}}_{ik} \leq t^* < {t^*_{on}}_{ik} + \delta^*_{ik} \\
1.0 & \text{if } t^* \geq {t^*_{on}}_{ik} + \delta^*_{ik}
\end{cases} \label{eq-branch-piecewise-transcription}
\end{align}

The dimensionless concentrations $u^*_{ij}$ and $s^*_{ij}$ are computed using the same piecewise analytical solutions as the single-branch model, but with branch-gene-specific parameters ${t^*_{on}}_{ik}$, $\delta^*_{ik}$, and $R_{on,ik}$, and cell-specific temporal coordinate ${t^*}_j$ determined by the stick-breaking process for branch $Z_j$.

**Conditional independence structure:**

Given branch assignments $\{Z_j\}_{j=1}^N$ and all parameters, the observations are conditionally independent:
\begin{align}
p(\{u_{ij}, s_{ij}\}_{i,j} \mid \{Z_j\}, \text{all parameters}) &= \prod_{j=1}^N \prod_{i=1}^G p(u_{ij}, s_{ij} \mid Z_j, \text{parameters}) \label{eq-conditional-independence}
\end{align}

**Observation model:**
\begin{align}
u_{ij} \mid Z_j = k &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot u^*_{ij}(k)) \label{eq-branch-u-obs} \\
s_{ij} \mid Z_j = k &\sim \text{Poisson}(\lambda_j \cdot U_{0i} \cdot s^*_{ij}(k)) \label{eq-branch-s-obs}
\end{align}

where $u^*_{ij}(k)$ and $s^*_{ij}(k)$ denote the dimensionless concentrations computed using branch $k$'s parameters and temporal coordinates.

**Marginal likelihood (integrating over branch assignments):**
\begin{align}
p(\{u_{ij}, s_{ij}\}_{i,j} \mid \text{parameters}) &= \prod_{j=1}^N \sum_{k=1}^K \pi_k \prod_{i=1}^G p(u_{ij}, s_{ij} \mid Z_j = k, \text{parameters}) \label{eq-marginal-likelihood}
\end{align}

**Complete data likelihood (given branch assignments):**
\begin{align}
p(\{u_{ij}, s_{ij}\}_{i,j}, \{Z_j\}_{j=1}^N \mid \text{parameters}) &= \prod_{j=1}^N \pi_{Z_j} \prod_{i=1}^G p(u_{ij}, s_{ij} \mid Z_j, \text{parameters}) \label{eq-complete-likelihood}
\end{align}

### Branch-Specific Parameter Structure

The branching mixture model introduces a **hierarchical parameter organization** that balances biological interpretability with computational efficiency. Parameters are strategically partitioned into shared and branch-specific categories based on biological considerations and identifiability requirements.

#### **Shared Parameters Across Branches**

**$\gamma^*_i$ (Relative degradation rate)**

- **Rationale**: mRNA degradation kinetics are primarily determined by sequence-specific features (3' UTR elements, miRNA binding sites, RNA-binding protein motifs) that are intrinsic to the gene and independent of developmental trajectory
- **Biological justification**: Degradation machinery (exonucleases, deadenylation complexes) operates consistently across cell types within the same organism
- **Mathematical advantage**: Reduces parameter space from $G \times K$ to $G$ parameters while maintaining biological realism
- **Identifiability**: Shared degradation rates enable borrowing strength across branches for better parameter estimation

**$U_{0i}$ (Characteristic concentration scale)**

- **Rationale**: Represents the gene's fundamental expression capacity, which reflects promoter strength, chromatin accessibility, and transcriptional machinery availability
- **Biological justification**: While absolute expression levels vary across branches, the characteristic scale represents the gene's intrinsic transcriptional potential
- **Mathematical advantage**: Separates scaling effects from temporal dynamics, maintaining dimensional consistency across branches
- **Identifiability**: Shared scaling parameters prevent confounding between branch-specific temporal effects and expression magnitude

#### **Branch-Specific Parameters**

**$T_{\max,k}$ (Branch-specific process duration)**

- **Definition**: Maximum dimensionless time for developmental process in branch $k$
- **Biological interpretation**: Different developmental trajectories may proceed at different rates, with some lineages requiring longer maturation times
- **Examples**:
  - Neuronal differentiation (slow, $T_{\max} \sim 10$) vs. myeloid differentiation (fast, $T_{\max} \sim 3$)
  - Stress response (rapid, $T_{\max} \sim 2$) vs. metabolic adaptation (gradual, $T_{\max} \sim 8$)
- **Mathematical role**: Provides branch-specific temporal scaling while maintaining stick-breaking identifiability

**${t^*_{on}}_{ik}$ (Branch-gene-specific onset time)**

- **Definition**: Dimensionless activation onset time for gene $i$ in branch $k$
- **Biological interpretation**: Different developmental trajectories activate the same genes at different relative timepoints
- **Examples**:
  - Transcription factor cascades: Early TFs activate first in committed lineages, later in multipotent cells
  - Metabolic genes: Glycolytic genes activate early in proliferative branches, late in quiescent branches
  - Stress response: Immediate early genes activate quickly in acute stress, slowly in chronic adaptation
- **Prior structure**: $\text{Normal}(\mu_{on,k}, \sigma_{on}^2)$ allows branch-specific timing while sharing variance across genes

**$\delta^*_{ik}$ (Branch-gene-specific activation duration)**

- **Definition**: Dimensionless activation duration for gene $i$ in branch $k$
- **Biological interpretation**: Same genes may have different activation durations across developmental trajectories
- **Examples**:
  - Cell cycle genes: Brief activation in rapidly dividing cells, prolonged in slowly cycling cells
  - Differentiation markers: Transient in intermediate states, sustained in terminal differentiation
  - Signaling molecules: Pulse-like in signaling cells, sustained in responding cells
- **Prior structure**: $\text{LogNormal}(\mu_{\delta,k}, \sigma_{\delta}^2)$ ensures positive durations with branch-specific means

**$R_{on,ik}$ (Branch-gene-specific fold-change)**

- **Definition**: Fold-change in transcription rate during activation for gene $i$ in branch $k$
- **Biological interpretation**: Same genes may be activated to different extents across developmental trajectories
- **Examples**:
  - Lineage markers: Strong activation in committed lineages, weak in multipotent cells
  - Metabolic enzymes: High fold-change in metabolically active branches, low in quiescent branches
  - Stress genes: Massive activation in stressed cells, moderate in adapted cells
- **Prior structure**: $\text{LogNormal}(\mu_{R,k}, \sigma_R^2)$ ensures positive fold-changes with branch-specific means

#### **Hyperparameter Interpretation**

**Branch-specific location parameters** ($\mu_{on,k}$, $\mu_{\delta,k}$, $\mu_{R,k}$):

- **Biological meaning**: Characteristic timing and expression patterns for each developmental trajectory
- **Identifiability**: Enable learning of branch-specific expression programs while sharing variance parameters
- **Flexibility**: Allow each branch to have distinct temporal and expression characteristics

**Shared variance parameters** ($\sigma_{on}^2$, $\sigma_{\delta}^2$, $\sigma_R^2$):

- **Statistical efficiency**: Borrowing strength across branches improves parameter estimation
- **Biological realism**: Gene-to-gene variation in timing and expression is similar across developmental contexts
- **Computational advantage**: Reduces parameter space while maintaining model flexibility

### Stick-Breaking Within Branches

The branching mixture model implements **independent stick-breaking processes** within each branch, maintaining all identifiability and computational advantages of the single-branch framework while enabling branch-specific temporal dynamics.

#### **Branch-Specific Stick-Breaking Construction**

The rigorous stick-breaking specification is provided in the Mathematical Description section above (equations \eqref{eq-branch-beta-variables-rigorous}-\eqref{eq-branch-ordering}). Each branch $k$ implements an independent stick-breaking process with the following key properties:

- **Independent Beta variables**: $V_{k,\ell} \sim \text{Beta}(1, \mathcal{N}_k - \ell)$ for each position $\ell$ within branch $k$
- **Recursive construction**: Temporal coordinates built sequentially using stick-breaking formula
- **Fixed anchors**: First cell at $t^* = 0$, last cell at $t^* = T_{\max,k}$
- **Proper ordering**: Ensures $0 = {t^*}_{j_{k,1}} < {t^*}_{j_{k,2}} < \cdots < {t^*}_{j_{k,\mathcal{N}_k}} = T_{\max,k}$

#### **Mathematical Properties of Branch-Specific Stick-Breaking**

**Ordering preservation within branches:**

From equation \eqref{eq-branch-ordering}, each branch maintains strict temporal ordering:
\begin{align}
0 = {t^*}_{j_{k,1}} < {t^*}_{j_{k,2}} < \cdots < {t^*}_{j_{k,\mathcal{N}_k}} = T_{\max,k} \quad \text{for all } k \in \{1, \ldots, K\} \label{eq-branch-ordering-property}
\end{align}

**Independence across branches:**

The Beta variables for different branches are mutually independent:
\begin{align}
\{V_{k,\ell}\}_{\ell=1}^{\mathcal{N}_k-1} \perp \{V_{k',\ell'}\}_{\ell'=1}^{\mathcal{N}_{k'}-1} \quad \text{for } k \neq k' \label{eq-branch-independence}
\end{align}

**Conditional independence of temporal coordinates:**

Given branch assignments $\{Z_j\}_{j=1}^N$ and process durations $\{T_{\max,k}\}_{k=1}^K$, the temporal coordinates are conditionally independent across branches:
\begin{align}
p(\{{t^*}_j\}_{j=1}^N \mid \{Z_j\}, \{T_{\max,k}\}) &= \prod_{k=1}^K p(\{{t^*}_j : j \in \mathcal{C}_k\} \mid T_{\max,k}) \label{eq-conditional-independence-time}
\end{align}

**Identifiability within each branch:**

Each branch maintains the same identifiability properties as the single-branch model:
- **Fixed anchors**: ${t^*}_{j_{k,1}} = 0$ and ${t^*}_{j_{k,\mathcal{N}_k}} = T_{\max,k}$ eliminate scaling symmetry
- **Independent gene parameters**: ${t^*_{on}}_{ik}$, $\delta^*_{ik}$ are sampled independently of $T_{\max,k}$ (equations \eqref{eq-branch-onset}-\eqref{eq-branch-fold-change})
- **Analytical tractability**: Same piecewise solutions apply within each branch

#### **Computational Complexity Analysis**

**Time complexity:**
- **Single-branch stick-breaking**: $O(N \log N)$ for $N$ cells
- **Multi-branch stick-breaking**: $O\left(\sum_{k=1}^K \mathcal{N}_k \log \mathcal{N}_k\right) = O(N \log N)$ since $\sum_{k=1}^K \mathcal{N}_k = N$
- **No asymptotic increase**: Branching does not increase computational complexity

**Memory complexity:**
- **Additional storage**: $O(K)$ for branch-specific parameters
- **Cell assignments**: $O(N)$ for storing $Z_j$ values
- **Total increase**: $O(K + N)$, linear in problem size

**Parallel computation opportunities:**
- **Independent branch processing**: Stick-breaking for each branch can be computed in parallel
- **Gene parameter updates**: Branch-gene parameters can be updated independently across branches
- **Likelihood evaluation**: Branch-specific likelihoods can be computed in parallel

#### **Implementation Considerations**

**Branch assignment updates:**

During MCMC sampling, branch assignments $Z_j$ are updated using the conditional posterior distribution:
\begin{align}
P(Z_j = k \mid \{u_{ij}, s_{ij}\}_{i=1}^G, \text{all other parameters}) &\propto \pi_k \prod_{i=1}^G p(u_{ij}, s_{ij} \mid Z_j = k, \text{parameters}) \label{eq-branch-assignment-posterior}
\end{align}

where the likelihood term is computed using branch $k$'s temporal coordinates and gene-specific parameters as specified in equations \eqref{eq-branch-u-obs}-\eqref{eq-branch-s-obs}.

**Stick-breaking recomputation:**

When branch assignments change, only the affected branches need stick-breaking recomputation:
- **Efficient updates**: Only recompute stick-breaking for branches that gained or lost cells
- **Unchanged branches**: Branches with stable membership retain their temporal coordinates
- **Computational savings**: Avoid full recomputation when only a few cells change branches

**Numerical stability:**

- **Beta variable bounds**: Ensure $V_{k,\ell} \in (0, 1)$ to prevent degenerate stick-breaking
- **Minimum branch size**: Require $\mathcal{N}_k \geq 2$ for meaningful stick-breaking (at least start and end points)
- **Empty branch handling**: Branches with $\mathcal{N}_k = 0$ are automatically excluded from likelihood computation

### Identifiability Analysis

The branching mixture model preserves all identifiability properties of the single-branch framework while introducing additional structure that enhances parameter recovery through **conditional independence** and **hierarchical regularization**.

#### **Preservation of Single-Branch Identifiability**

**Theorem (Branch-Conditional Identifiability):**

Given branch assignments $\{Z_j\}_{j=1}^N$, each branch $k$ maintains the same identifiability properties as the single-branch model.

**Proof:**

1. **Fixed anchors within branch**: For cells in branch $k$, we have ${t^*}_{j_1} = 0$ and ${t^*}_{j_{\mathcal{N}_k}} = T_{\max,k}$

2. **Independent gene parameters**: ${t^*_{on}}_{ik}$ and $\delta^*_{ik}$ are sampled independently of $T_{\max,k}$

3. **No scaling symmetry**: The same argument as in the single-branch case applies within each branch

4. **Analytical solutions**: The piecewise analytical solutions within each branch are identical to the single-branch case

Therefore, conditional on branch assignments, each branch is identifiable. □

#### **Enhanced Identifiability Through Mixture Structure**

**Cross-branch parameter constraints:**

The mixture structure introduces additional identifiability through **cross-branch comparisons**:

\begin{align}
\mathcal{L}_{\text{mixture}} &= \prod_{j=1}^N \sum_{k=1}^K \pi_k \cdot \mathcal{L}_k(\text{data}_j \mid \text{branch } k) \\
&\neq \prod_{j=1}^N \sum_{k=1}^K \pi_k \cdot \mathcal{L}_k(\text{data}_j \mid \text{scaled branch } k)
\end{align}

**Theorem (Mixture Identifiability Enhancement):**

The mixture likelihood is not invariant under branch-specific parameter scaling, providing additional identifiability constraints beyond single-branch identifiability.

**Proof:**

1. **Asymmetric scaling**: Scaling parameters in branch $k$ but not branch $k'$ changes the relative likelihood contributions

2. **Branch assignment sensitivity**: Cells near branch boundaries become more or less likely to be assigned to scaled branches

3. **Cross-branch competition**: The mixture structure creates competition between branches that prevents arbitrary scaling

4. **Hierarchical constraints**: Shared hyperparameters ($\sigma_{on}^2$, $\sigma_{\delta}^2$, $\sigma_R^2$) provide additional regularization

Therefore, the mixture structure enhances identifiability beyond the single-branch case. □

#### **Identifiability of Branch Structure Parameters**

**Number of branches ($K$):**

- **Identifiable through**: Model comparison using information criteria (WAIC, LOO-CV)
- **Practical bounds**: $K \leq N/2$ to ensure sufficient cells per branch for stick-breaking
- **Biological constraints**: $K$ should reflect known developmental trajectories

**Branch probabilities ($\boldsymbol{\pi}$):**

- **Identifiable through**: Observed frequencies of branch assignments
- **Dirichlet prior**: Provides regularization while allowing flexible branch sizes
- **Constraint**: $\sum_{k=1}^K \pi_k = 1$ ensures proper probability distribution

**Branch assignments ($\{Z_j\}$):**

- **Identifiable through**: Likelihood comparison across branches for each cell
- **Uncertainty quantification**: Posterior probabilities $P(Z_j = k \mid \text{data})$ provide assignment confidence
- **Soft clustering**: Cells can have uncertain branch assignments, reflecting biological reality

#### **Practical Identifiability Considerations**

**Minimum branch size requirements:**

- **Stick-breaking constraint**: Each branch needs $\mathcal{N}_k \geq 2$ for meaningful temporal ordering
- **Parameter estimation**: Larger branches provide better parameter estimates
- **Recommended minimum**: $\mathcal{N}_k \geq 10$ for stable parameter recovery

**Gene parameter identifiability:**

- **Shared parameters**: $\gamma^*_i$ and $U_{0i}$ benefit from pooling across branches
- **Branch-specific parameters**: Require sufficient cells and temporal coverage within each branch
- **Hierarchical regularization**: Branch-specific means with shared variances improve identifiability

**Temporal coverage requirements:**

- **Within-branch coverage**: Each branch should span sufficient temporal range for parameter recovery
- **Cross-branch comparison**: Overlapping temporal ranges enable branch discrimination
- **Gene activation coverage**: Each branch should contain cells before, during, and after gene activation events

### Biological Interpretation

The branching mixture model provides a **mathematically rigorous framework** for modeling complex developmental processes where cells follow distinct trajectories with different temporal dynamics and gene expression programs.

#### **Developmental Biology Applications**

**Cell fate decisions and lineage bifurcations:**

The model naturally captures **binary and multi-way cell fate decisions** where progenitor cells commit to distinct developmental lineages:

- **Hematopoiesis**: Multipotent stem cells differentiating into myeloid vs. lymphoid lineages
- **Neural development**: Neural progenitors becoming neurons vs. glia
- **Embryonic development**: Pluripotent cells committing to different germ layers
- **Tissue regeneration**: Stem cells responding to injury with different repair programs

**Branch-specific temporal dynamics:**

Different developmental trajectories often proceed at **different rates** and with **different timing**:

- **Fast vs. slow differentiation**: Some lineages mature rapidly (hours), others slowly (days)
- **Sequential vs. parallel activation**: Genes may activate in different orders across branches
- **Transient vs. sustained expression**: Same genes may show different temporal patterns across lineages

**Examples of branch-specific gene expression patterns:**

1. **Transcription factor cascades**:
   - **Branch 1 (Neural)**: Early activation of neuronal TFs, sustained expression of synaptic genes
   - **Branch 2 (Glial)**: Later activation of glial TFs, transient expression of migration genes

2. **Metabolic reprogramming**:
   - **Branch 1 (Proliferative)**: Early glycolytic gene activation, sustained cell cycle gene expression
   - **Branch 2 (Quiescent)**: Early oxidative metabolism genes, transient stress response activation

3. **Stress response pathways**:
   - **Branch 1 (Adaptation)**: Gradual activation of protective genes, sustained expression
   - **Branch 2 (Apoptosis)**: Rapid activation of death genes, transient survival gene expression

#### **Experimental Design Connections**

**Single-cell trajectory inference:**

The model provides a **probabilistic foundation** for trajectory inference methods:

- **Pseudotime estimation**: Branch-specific temporal coordinates provide principled pseudotime
- **Lineage tracing**: Branch assignments correspond to inferred lineage relationships
- **Trajectory topology**: Number of branches and their relationships reflect developmental structure

**Lineage tracing validation:**

The model can be **validated against experimental lineage tracing**:

- **Clonal analysis**: Compare inferred branch assignments to known clonal relationships
- **Barcode sequencing**: Use genetic barcodes to validate branch structure
- **Time-course experiments**: Compare inferred temporal coordinates to known sampling times

**Perturbation experiments:**

The model enables **quantitative analysis of developmental perturbations**:

- **Knockout effects**: Compare branch structure and gene expression patterns in wild-type vs. knockout
- **Drug treatments**: Assess how chemical perturbations alter developmental trajectories
- **Environmental stress**: Model how external conditions affect lineage commitment and timing

#### **Connection to Established Developmental Biology Concepts**

**Waddington's epigenetic landscape:**

The branching model provides a **quantitative implementation** of Waddington's landscape metaphor:

- **Branches as valleys**: Each developmental trajectory corresponds to a valley in the landscape
- **Branch probabilities as basin sizes**: $\pi_k$ reflects the relative attractiveness of each trajectory
- **Temporal coordinates as progress**: ${t^*}_j$ represents progress down the developmental valley
- **Gene expression as landscape features**: Branch-specific parameters define the molecular landscape

**Canalization and developmental constraints:**

The model captures **developmental canalization** through parameter structure:

- **Shared degradation rates**: Reflect conserved post-transcriptional machinery
- **Branch-specific timing**: Captures lineage-specific developmental programs
- **Hierarchical priors**: Represent evolutionary constraints on developmental variation

**Developmental plasticity and robustness:**

The mixture structure enables modeling of **developmental plasticity**:

- **Branch assignment uncertainty**: Reflects cellular plasticity and fate choice flexibility
- **Parameter variation**: Captures individual cell variation within developmental programs
- **Environmental responsiveness**: Branch probabilities can depend on external conditions

#### **Clinical and Therapeutic Applications**

**Disease modeling:**

The framework can model **pathological developmental processes**:

- **Cancer progression**: Tumor cells following different evolutionary trajectories
- **Developmental disorders**: Disrupted lineage specification and timing
- **Aging**: Age-related changes in stem cell differentiation capacity

**Drug discovery:**

The model enables **quantitative assessment of therapeutic interventions**:

- **Target identification**: Genes with branch-specific expression patterns as therapeutic targets
- **Timing optimization**: Optimal timing of interventions based on developmental stage
- **Combination therapy**: Targeting multiple branches simultaneously

**Regenerative medicine:**

The framework supports **rational design of regenerative therapies**:

- **Directed differentiation**: Optimizing protocols to bias cells toward desired branches
- **Reprogramming efficiency**: Quantifying success of cellular reprogramming approaches
- **Tissue engineering**: Designing scaffolds that support specific developmental trajectories

### Computational Considerations

The branching mixture model maintains **computational efficiency** while significantly expanding modeling capabilities through careful algorithmic design and mathematical structure preservation.

#### **Scalability Analysis**

**Time complexity scaling:**

\begin{align}
\text{Single-branch model:} &\quad O(N \log N + NG) \\
\text{Branching mixture model:} &\quad O(K \cdot N \log N + KNG + NK)
\end{align}

where:

- $N$ = number of cells
- $G$ = number of genes
- $K$ = number of branches

**Asymptotic behavior:**

- **Linear in $K$**: Computational cost scales linearly with number of branches
- **No interaction terms**: $K$, $N$, and $G$ scaling factors are multiplicative, not exponential
- **Practical bounds**: For typical values ($K \leq 10$, $N \leq 10^4$, $G \leq 10^3$), computational cost remains manageable

**Memory complexity:**
\begin{align}
\text{Additional memory:} &\quad O(KG + KN + K) \\
&= O(K(G + N + 1))
\end{align}

**Storage breakdown:**

- **Branch-gene parameters**: $O(KG)$ for ${t^*_{on}}_{ik}$, $\delta^*_{ik}$, $R_{on,ik}$
- **Branch assignments**: $O(N)$ for $Z_j$ values
- **Branch-specific temporal coordinates**: $O(KN)$ for stick-breaking variables
- **Branch probabilities**: $O(K)$ for $\boldsymbol{\pi}$

#### **Algorithmic Optimizations**

**Parallel computation strategies:**

1. **Branch-parallel likelihood evaluation**: The marginal likelihood in equation \eqref{eq-marginal-likelihood} can be computed in parallel across branches since each branch's contribution is independent given the parameters.

2. **Gene-parallel parameter updates**: Branch-gene-specific parameters (equations \eqref{eq-branch-onset}-\eqref{eq-branch-fold-change}) can be updated in parallel across genes within each branch due to conditional independence.

3. **Cell-parallel branch assignment updates**: The posterior probabilities in equation \eqref{eq-branch-assignment-posterior} can be computed in parallel across cells since assignments are conditionally independent given all other parameters.

**Efficient MCMC sampling:**

**Block updates for branch structure:**

- **Joint branch probability update**: Sample $\boldsymbol{\pi}$ using conjugate Dirichlet posterior
- **Efficient branch assignment**: Use categorical sampling with precomputed likelihoods
- **Adaptive branch proposals**: Propose branch reassignments based on likelihood ratios

**Hierarchical parameter updates:**

- **Shared parameter pooling**: Update $\gamma^*_i$ and $U_{0i}$ using data from all branches
- **Branch-specific parameter blocks**: Update all parameters for branch $k$ jointly
- **Hyperparameter updates**: Use conjugate priors where possible for efficient sampling

**Stick-breaking optimizations:**

- **Incremental updates**: Only recompute stick-breaking for branches with changed membership
- **Cached computations**: Store intermediate stick-breaking results to avoid recomputation
- **Vectorized operations**: Use efficient linear algebra for Beta variable sampling

#### **Implementation Considerations**

**Numerical stability:**

**Beta variable sampling**: The Beta variables $V_{k,\ell} \sim \text{Beta}(1, \mathcal{N}_k - \ell)$ in equation \eqref{eq-branch-beta-variables-rigorous} should be bounded away from 0 and 1 to prevent degenerate stick-breaking constructions.

**Likelihood computation**: The marginal likelihood in equation \eqref{eq-marginal-likelihood} should be computed in log-space to prevent numerical overflow/underflow, particularly when $K$ is large or when branch probabilities $\pi_k$ are small.

**Memory management:**

**Efficient data structures:**
- **Sparse representations**: Gene expression matrices can be stored sparsely since many genes may have zero counts
- **Branch indexing**: Maintain efficient mappings between cells and their branch assignments $Z_j$
- **Parameter caching**: Cache frequently accessed combinations of branch-gene parameters

**Memory-efficient processing**: For large datasets, branches can be processed sequentially rather than simultaneously to limit memory usage, taking advantage of the conditional independence structure in equations \eqref{eq-conditional-independence} and \eqref{eq-conditional-independence-time}.

#### **Validation and Diagnostics**

**Convergence diagnostics:**

**Branch-specific convergence:**

- **Within-branch parameter convergence**: Monitor $\hat{R}$ statistics for each branch separately
- **Cross-branch parameter comparison**: Ensure branch-specific parameters are distinguishable
- **Branch assignment stability**: Track branch assignment changes across MCMC iterations

**Model selection criteria:**

**Information criteria for branch number:**
\begin{align}
\text{WAIC}_K &= -2 \sum_{j=1}^N \log \mathbb{E}[p(y_j \mid \theta)] + 2 p_{\text{eff}} \\
\text{LOO-CV}_K &= \sum_{j=1}^N \log p(y_j \mid y_{-j})
\end{align}

**Cross-validation strategies:**

- **Leave-one-branch-out**: Assess model performance when excluding entire branches
- **Temporal cross-validation**: Validate on held-out time points within each branch
- **Gene-wise validation**: Test parameter recovery for held-out genes

**Parameter recovery validation:**

**Branch-specific validation metrics:**

- **Branch assignment accuracy**: Compare inferred vs. true branch assignments
- **Within-branch parameter recovery**: Assess parameter recovery within each branch
- **Cross-branch parameter discrimination**: Verify that branch-specific parameters are distinguishable

**Computational benchmarking:**

Performance evaluation should focus on the scaling properties derived from the mathematical structure:
- **Time complexity**: $O(K \cdot N \log N + KNG + NK)$ as specified in equations \eqref{eq-branch-beta-variables-rigorous}-\eqref{eq-branch-time-scaling-rigorous}
- **Memory complexity**: $O(K(G + N + 1))$ for storing branch-specific parameters and assignments
- **Convergence assessment**: Monitor convergence of branch assignments $Z_j$ and branch-specific parameters using standard MCMC diagnostics

This comprehensive computational framework ensures that the branching mixture model remains **practically implementable** while providing **rigorous mathematical foundations** for modeling complex developmental processes with multiple trajectories.
