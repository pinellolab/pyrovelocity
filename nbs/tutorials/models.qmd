---
title: "Model definition"
execute:
  freeze: true
  eval: true
  warning: false
  error: false
  cache: true
toc: true
number-sections: true
highlight-style: gruvbox
csl: ../../bibstyle.csl
lightbox: auto
format:
  html:
    html-math-method: katex
#   ipynb: default
---

# Introduction to PyroVelocity Modular Models

This tutorial introduces PyroVelocity modular models, which follows a Protocol-First architecture with composable components. The modular implementation provides a flexible and extensible framework for building RNA velocity models.

## Prerequisites

Before starting, make sure you have PyroVelocity [installed](../guides/installation.qmd).

## Basic Usage

Let's start with a realistic example using the bifurcation_14 dataset and the modular implementation:

```python
import torch
import pyro
import numpy as np
import matplotlib.pyplot as plt
import scanpy as sc
import scvelo as scv
from pyrovelocity.utils import print_anndata, anndata_string, print_string_diff
from pyrovelocity.models.modular import PyroVelocityModel
from pyrovelocity.models.modular.factory import create_standard_model
from pyrovelocity.io.datasets import bifurcation_14

# Set random seed for reproducibility
torch.manual_seed(42)
np.random.seed(42)
pyro.set_rng_seed(42)

# Load the bifurcation_14 dataset
# This is a synthetic dataset with a single bifurcation in its differentiation trajectory
adata = bifurcation_14()
print("Loaded bifurcation_14 dataset:")
print_anndata(adata)
initial_data_state_representation = anndata_string(adata)

# Set up AnnData for PyroVelocity
adata = PyroVelocityModel.setup_anndata(adata)
post_setup_anndata_representation = anndata_string(adata)
print_string_diff(
    initial_data_state_representation,
    post_setup_anndata_representation,
    diff_title="Setup AnnData diff",
)
print_anndata(adata)

# Compute PCA and UMAP embeddings if not already present
if 'X_pca' not in adata.obsm:
    sc.pp.pca(adata)
if 'X_umap' not in adata.obsm:
    sc.pp.neighbors(adata)
    sc.tl.umap(adata)
post_embedding_representation = anndata_string(adata)
print_string_diff(
    post_setup_anndata_representation,
    post_embedding_representation,
    diff_title="Embedding diff",
)
print_anndata(adata)

# Create a standard model with default components
model = create_standard_model()
print(model)

# Train the model
model.train(
    adata=adata,
    max_epochs=50,  # Use more epochs for better results
    learning_rate=0.01,
    use_gpu=False  # Set to True if GPU is available
)

# Generate posterior samples and compute velocity in one step
# The new unified get_velocity method computes both velocity and uncertainty
adata_with_velocity = model.get_velocity(
    adata=adata,
    num_samples=100,  # Use more samples for better uncertainty estimates
    basis='umap',
    compute_uncertainty=True,
    uncertainty_method='std',
    model_name='pyrovelocity'
)

# Print the updated AnnData structure
print("AnnData after velocity computation:")
print_anndata(adata_with_velocity)

# Show what fields were added
post_velocity_representation = anndata_string(adata_with_velocity)
print_string_diff(
    post_embedding_representation,
    post_velocity_representation,
    diff_title="Velocity computation diff",
)
```

## Understanding the Modular Architecture

The modular implementation is based on a Protocol-First architecture with five main component types:

1. **Dynamics Model**: Defines the mathematical models of RNA dynamics
2. **Prior Model**: Defines prior distributions for model parameters
3. **Likelihood Model**: Defines observation distributions
4. **Observation Model**: Handles data preprocessing and transformation
5. **Guide Model**: Creates guide functions for variational inference

Each component implements a Protocol interface, allowing for flexible composition and extension.

## Creating Custom Models

You can create custom models by combining different components using the registry system:

```python
from pyrovelocity.models.modular.registry import (
    DynamicsModelRegistry,
    PriorModelRegistry,
    LikelihoodModelRegistry,
    ObservationModelRegistry,
    InferenceGuideRegistry
)
from pyrovelocity.models.modular.model import PyroVelocityModel

# Create components using the registry
dynamics_model = DynamicsModelRegistry.create("legacy", shared_time=True, t_scale_on=False)
prior_model = PriorModelRegistry.create("lognormal")
likelihood_model = LikelihoodModelRegistry.create("legacy")
observation_model = ObservationModelRegistry.create("standard", correct_library_size=True)
guide_model = InferenceGuideRegistry.create("auto")

# Create model
custom_model = PyroVelocityModel(
    dynamics_model=dynamics_model,
    prior_model=prior_model,
    likelihood_model=likelihood_model,
    observation_model=observation_model,
    guide_model=guide_model
)

# Train the model
custom_model.train(
    adata=adata_with_velocity,  # Use the data with embeddings
    max_epochs=50,
    learning_rate=0.01,
    use_gpu=False
)

# Compute velocity with the custom model
custom_adata = custom_model.get_velocity(
    adata=adata_with_velocity,
    num_samples=100,
    basis='umap',
    compute_uncertainty=True,
    model_name='custom_legacy'
)
```

## Using Factory Functions

The modular implementation provides factory functions for creating models with different configurations:

```python
from pyrovelocity.models.modular.factory import (
    create_standard_model,
    create_model_from_config,
    create_legacy_model1,
    create_legacy_model2
)
from pyrovelocity.models.modular.config import ModelConfig

# Create a standard model (recommended for new projects)
standard_model = create_standard_model()

# Create a model that replicates the legacy implementation (add_offset=False)
legacy_model1 = create_legacy_model1()

# Create a model that replicates the legacy implementation (add_offset=True)
legacy_model2 = create_legacy_model2()

# Create a model from a configuration
config = ModelConfig.standard()
config_model = create_model_from_config(config)

# Train and use any of these models
legacy_model1.train(adata=adata_with_velocity, max_epochs=50)

# The new unified get_velocity method returns the mutated AnnData object
adata_legacy = legacy_model1.get_velocity(
    adata=adata_with_velocity,
    num_samples=100,
    basis='umap',
    compute_uncertainty=True,
    model_name='legacy1'
)

print("Available velocity layers:")
for layer in adata_legacy.layers.keys():
    if 'velocity' in layer:
        print(f"- {layer}")
```

## Visualizing Results

After training the model and computing velocity, you can visualize the results using scvelo's plotting functions. The velocity data is stored in the format expected by scvelo:

```python
import matplotlib.pyplot as plt

# Add leiden clustering for visualization
sc.tl.leiden(adata_with_velocity)

# Set up the plot
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Plot 1: Standard velocity embedding
scv.pl.velocity_embedding_grid(
    adata_with_velocity,
    basis='umap',
    color='leiden',
    title='PyroVelocity Standard Model',
    vkey='velocity_pyrovelocity',  # Use the velocity key added by get_velocity
    s=15,
    alpha=1,
    linewidth=0.5,
    ax=axes[0],
    show=False,
    legend_loc='right margin',
    density=0.4,
    scale=0.2,
    arrow_size=2,
    arrow_length=2,
    arrow_color='black',
)

# Plot 2: Legacy model comparison (if computed)
if 'velocity_legacy1' in adata_legacy.layers:
    scv.pl.velocity_embedding_grid(
        adata_legacy,
        basis='umap',
        color='leiden',
        title='PyroVelocity Legacy Model',
        vkey='velocity_legacy1',
        s=15,
        alpha=1,
        linewidth=0.5,
        ax=axes[1],
        show=False,
        legend_loc='right margin',
        density=0.4,
        scale=0.2,
        arrow_size=2,
        arrow_length=2,
        arrow_color='black',
    )
else:
    axes[1].text(0.5, 0.5, 'Legacy model\nnot computed',
                ha='center', va='center', transform=axes[1].transAxes)
    axes[1].axis('off')

plt.tight_layout()
plt.show()

# Display uncertainty information if computed
if 'velocity_pyrovelocity_uncertainty' in adata_with_velocity.var.columns:
    print("Velocity uncertainty statistics:")
    uncertainty = adata_with_velocity.var['velocity_pyrovelocity_uncertainty']
    print(f"Mean uncertainty: {uncertainty.mean():.4f}")
    print(f"Std uncertainty: {uncertainty.std():.4f}")
    print(f"Min uncertainty: {uncertainty.min():.4f}")
    print(f"Max uncertainty: {uncertainty.max():.4f}")
```

## Conclusion

This tutorial introduced the basics of PyroVelocity's modular implementation. The modular architecture provides a flexible and extensible framework for building RNA velocity models, allowing you to customize components and create models tailored to your specific needs.

For more advanced usage, refer to the [API reference](../reference/models.PyroVelocityModel.qmd) and [how-to guides](../guides/model_components.qmd).
